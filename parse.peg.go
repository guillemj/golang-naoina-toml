package toml

// Code generated by peg -switch -inline parse.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleTOML
	ruleExpression
	rulenewline
	rulews
	rulewsnl
	rulecomment
	ruleval
	ruletable
	rulestdTable
	rulearrayTable
	ruleinlineTable
	ruleinlineTableKeyValues
	rulekeyval
	rulekey
	rulebareKey
	rulequotedKey
	ruletableKey
	ruletableKeyComp
	ruletableKeySep
	ruleinlineTableValSep
	ruleboolean
	ruleinteger
	ruledecimalInt
	ruledecimalDigit
	rulehexInt
	rulehexDigit
	ruleoctalInt
	ruleoctalDigit
	rulebinaryInt
	rulebinaryDigit
	rulefloat
	rulefloatDigits
	rulefloatFrac
	rulefloatExp
	ruleescaped
	ruleescape
	rulehexQuad
	rulestring
	rulebasicString
	rulebasicChar
	rulebasicUnescaped
	rulemlBasicString
	rulemlBasicBody
	ruleliteralString
	ruleliteralChar
	rulemlLiteralString
	rulemlLiteralBody
	rulemlLiteralChar
	ruledateFullYear
	ruledateMonth
	ruledateMDay
	ruletimeHour
	ruletimeMinute
	ruletimeSecond
	ruletimeSecfrac
	ruletimeNumoffset
	ruletimeOffset
	rulepartialTime
	rulefullDate
	rulefullTime
	ruledatetime
	ruledigitDual
	ruledigitQuad
	rulearray
	rulearrayValues
	rulearraySep
	ruleAction0
	rulePegText
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
)

var rul3s = [...]string{
	"Unknown",
	"TOML",
	"Expression",
	"newline",
	"ws",
	"wsnl",
	"comment",
	"val",
	"table",
	"stdTable",
	"arrayTable",
	"inlineTable",
	"inlineTableKeyValues",
	"keyval",
	"key",
	"bareKey",
	"quotedKey",
	"tableKey",
	"tableKeyComp",
	"tableKeySep",
	"inlineTableValSep",
	"boolean",
	"integer",
	"decimalInt",
	"decimalDigit",
	"hexInt",
	"hexDigit",
	"octalInt",
	"octalDigit",
	"binaryInt",
	"binaryDigit",
	"float",
	"floatDigits",
	"floatFrac",
	"floatExp",
	"escaped",
	"escape",
	"hexQuad",
	"string",
	"basicString",
	"basicChar",
	"basicUnescaped",
	"mlBasicString",
	"mlBasicBody",
	"literalString",
	"literalChar",
	"mlLiteralString",
	"mlLiteralBody",
	"mlLiteralChar",
	"dateFullYear",
	"dateMonth",
	"dateMDay",
	"timeHour",
	"timeMinute",
	"timeSecond",
	"timeSecfrac",
	"timeNumoffset",
	"timeOffset",
	"partialTime",
	"fullDate",
	"fullTime",
	"datetime",
	"digitDual",
	"digitQuad",
	"array",
	"arrayValues",
	"arraySep",
	"Action0",
	"PegText",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type tomlParser struct {
	toml

	Buffer string
	buffer []rune
	rules  [95]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *tomlParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *tomlParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *tomlParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *tomlParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *tomlParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *tomlParser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func (p *tomlParser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:
			_ = buffer
		case ruleAction1:
			p.SetTableSource(begin, end)
		case ruleAction2:
			p.Newline()
		case ruleAction3:
			p.SetTime(begin, end)
		case ruleAction4:
			p.SetFloat(begin, end)
		case ruleAction5:
			p.SetInteger(begin, end)
		case ruleAction6:
			p.SetString(begin, end)
		case ruleAction7:
			p.SetBool(begin, end)
		case ruleAction8:
			p.SetArray(begin, end)
		case ruleAction9:
			p.SetInlineTableSource(begin, end)
		case ruleAction10:
			p.SetTable(p.buffer, begin, end)
		case ruleAction11:
			p.SetArrayTable(p.buffer, begin, end)
		case ruleAction12:
			p.StartInlineTable()
		case ruleAction13:
			p.EndInlineTable()
		case ruleAction14:
			p.AddKeyValue()
		case ruleAction15:
			p.SetKey(p.buffer, begin, end)
		case ruleAction16:
			p.SetKey(p.buffer, begin, end)
		case ruleAction17:
			p.AddTableKey()
		case ruleAction18:
			p.SetBasicString(p.buffer, begin, end)
		case ruleAction19:
			p.SetMultilineBasicString()
		case ruleAction20:
			p.AddMultilineBasicQuote()
		case ruleAction21:
			p.AddMultilineBasicBody(p.buffer, begin, end)
		case ruleAction22:
			p.SetLiteralString(p.buffer, begin, end)
		case ruleAction23:
			p.SetMultilineLiteralString(p.buffer, begin, end)
		case ruleAction24:
			p.StartArray()
		case ruleAction25:
			p.AddArrayVal()
		case ruleAction26:
			p.AddArrayVal()

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*tomlParser) error {
	return func(p *tomlParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*tomlParser) error {
	return func(p *tomlParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *tomlParser) Init(options ...func(*tomlParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 TOML <- <(Expression (newline Expression)* newline* !. Action0)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[ruleExpression]() {
					goto l0
				}
			l2:
				{
					position3, tokenIndex3 := position, tokenIndex
					if !_rules[rulenewline]() {
						goto l3
					}
					if !_rules[ruleExpression]() {
						goto l3
					}
					goto l2
				l3:
					position, tokenIndex = position3, tokenIndex3
				}
			l4:
				{
					position5, tokenIndex5 := position, tokenIndex
					if !_rules[rulenewline]() {
						goto l5
					}
					goto l4
				l5:
					position, tokenIndex = position5, tokenIndex5
				}
				{
					position6, tokenIndex6 := position, tokenIndex
					if !matchDot() {
						goto l6
					}
					goto l0
				l6:
					position, tokenIndex = position6, tokenIndex6
				}
				{
					add(ruleAction0, position)
				}
				add(ruleTOML, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 Expression <- <((<(ws table ws comment? (wsnl keyval ws comment?)*)> Action1) / (ws keyval ws comment?) / (ws comment?) / ws)> */
		func() bool {
			position8, tokenIndex8 := position, tokenIndex
			{
				position9 := position
				{
					position10, tokenIndex10 := position, tokenIndex
					{
						position12 := position
						if !_rules[rulews]() {
							goto l11
						}
						{
							position13 := position
							{
								position14, tokenIndex14 := position, tokenIndex
								{
									position16 := position
									if buffer[position] != rune('[') {
										goto l15
									}
									position++
									if !_rules[rulews]() {
										goto l15
									}
									{
										position17 := position
										if !_rules[ruletableKey]() {
											goto l15
										}
										add(rulePegText, position17)
									}
									if !_rules[rulews]() {
										goto l15
									}
									if buffer[position] != rune(']') {
										goto l15
									}
									position++
									{
										add(ruleAction10, position)
									}
									add(rulestdTable, position16)
								}
								goto l14
							l15:
								position, tokenIndex = position14, tokenIndex14
								{
									position19 := position
									if buffer[position] != rune('[') {
										goto l11
									}
									position++
									if buffer[position] != rune('[') {
										goto l11
									}
									position++
									if !_rules[rulews]() {
										goto l11
									}
									{
										position20 := position
										if !_rules[ruletableKey]() {
											goto l11
										}
										add(rulePegText, position20)
									}
									if !_rules[rulews]() {
										goto l11
									}
									if buffer[position] != rune(']') {
										goto l11
									}
									position++
									if buffer[position] != rune(']') {
										goto l11
									}
									position++
									{
										add(ruleAction11, position)
									}
									add(rulearrayTable, position19)
								}
							}
						l14:
							add(ruletable, position13)
						}
						if !_rules[rulews]() {
							goto l11
						}
						{
							position22, tokenIndex22 := position, tokenIndex
							if !_rules[rulecomment]() {
								goto l22
							}
							goto l23
						l22:
							position, tokenIndex = position22, tokenIndex22
						}
					l23:
					l24:
						{
							position25, tokenIndex25 := position, tokenIndex
							if !_rules[rulewsnl]() {
								goto l25
							}
							if !_rules[rulekeyval]() {
								goto l25
							}
							if !_rules[rulews]() {
								goto l25
							}
							{
								position26, tokenIndex26 := position, tokenIndex
								if !_rules[rulecomment]() {
									goto l26
								}
								goto l27
							l26:
								position, tokenIndex = position26, tokenIndex26
							}
						l27:
							goto l24
						l25:
							position, tokenIndex = position25, tokenIndex25
						}
						add(rulePegText, position12)
					}
					{
						add(ruleAction1, position)
					}
					goto l10
				l11:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[rulews]() {
						goto l29
					}
					if !_rules[rulekeyval]() {
						goto l29
					}
					if !_rules[rulews]() {
						goto l29
					}
					{
						position30, tokenIndex30 := position, tokenIndex
						if !_rules[rulecomment]() {
							goto l30
						}
						goto l31
					l30:
						position, tokenIndex = position30, tokenIndex30
					}
				l31:
					goto l10
				l29:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[rulews]() {
						goto l32
					}
					{
						position33, tokenIndex33 := position, tokenIndex
						if !_rules[rulecomment]() {
							goto l33
						}
						goto l34
					l33:
						position, tokenIndex = position33, tokenIndex33
					}
				l34:
					goto l10
				l32:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[rulews]() {
						goto l8
					}
				}
			l10:
				add(ruleExpression, position9)
			}
			return true
		l8:
			position, tokenIndex = position8, tokenIndex8
			return false
		},
		/* 2 newline <- <((('\r' '\n') / '\n') Action2)> */
		func() bool {
			position35, tokenIndex35 := position, tokenIndex
			{
				position36 := position
				{
					position37, tokenIndex37 := position, tokenIndex
					if buffer[position] != rune('\r') {
						goto l38
					}
					position++
					if buffer[position] != rune('\n') {
						goto l38
					}
					position++
					goto l37
				l38:
					position, tokenIndex = position37, tokenIndex37
					if buffer[position] != rune('\n') {
						goto l35
					}
					position++
				}
			l37:
				{
					add(ruleAction2, position)
				}
				add(rulenewline, position36)
			}
			return true
		l35:
			position, tokenIndex = position35, tokenIndex35
			return false
		},
		/* 3 ws <- <(' ' / '\t')*> */
		func() bool {
			{
				position41 := position
			l42:
				{
					position43, tokenIndex43 := position, tokenIndex
					{
						position44, tokenIndex44 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l45
						}
						position++
						goto l44
					l45:
						position, tokenIndex = position44, tokenIndex44
						if buffer[position] != rune('\t') {
							goto l43
						}
						position++
					}
				l44:
					goto l42
				l43:
					position, tokenIndex = position43, tokenIndex43
				}
				add(rulews, position41)
			}
			return true
		},
		/* 4 wsnl <- <((&('\t') '\t') | (&(' ') ' ') | (&('\n' | '\r') newline))*> */
		func() bool {
			{
				position47 := position
			l48:
				{
					position49, tokenIndex49 := position, tokenIndex
					{
						switch buffer[position] {
						case '\t':
							if buffer[position] != rune('\t') {
								goto l49
							}
							position++
						case ' ':
							if buffer[position] != rune(' ') {
								goto l49
							}
							position++
						default:
							if !_rules[rulenewline]() {
								goto l49
							}
						}
					}

					goto l48
				l49:
					position, tokenIndex = position49, tokenIndex49
				}
				add(rulewsnl, position47)
			}
			return true
		},
		/* 5 comment <- <('#' <('\t' / [ -\U0010ffff])*>)> */
		func() bool {
			position51, tokenIndex51 := position, tokenIndex
			{
				position52 := position
				if buffer[position] != rune('#') {
					goto l51
				}
				position++
				{
					position53 := position
				l54:
					{
						position55, tokenIndex55 := position, tokenIndex
						{
							position56, tokenIndex56 := position, tokenIndex
							if buffer[position] != rune('\t') {
								goto l57
							}
							position++
							goto l56
						l57:
							position, tokenIndex = position56, tokenIndex56
							if c := buffer[position]; c < rune(' ') || c > rune('\U0010ffff') {
								goto l55
							}
							position++
						}
					l56:
						goto l54
					l55:
						position, tokenIndex = position55, tokenIndex55
					}
					add(rulePegText, position53)
				}
				add(rulecomment, position52)
			}
			return true
		l51:
			position, tokenIndex = position51, tokenIndex51
			return false
		},
		/* 6 val <- <((<datetime> Action3) / (<float> Action4) / ((&('{') (<inlineTable> Action9)) | (&('[') (<array> Action8)) | (&('f' | 't') (<boolean> Action7)) | (&('"' | '\'') (<string> Action6)) | (&('+' | '-' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') (<integer> Action5))))> */
		func() bool {
			position58, tokenIndex58 := position, tokenIndex
			{
				position59 := position
				{
					position60, tokenIndex60 := position, tokenIndex
					{
						position62 := position
						{
							position63 := position
							{
								position64, tokenIndex64 := position, tokenIndex
								{
									position66 := position
									{
										position67 := position
										{
											position68 := position
											if !_rules[ruledigitDual]() {
												goto l65
											}
											if !_rules[ruledigitDual]() {
												goto l65
											}
											add(ruledigitQuad, position68)
										}
										add(ruledateFullYear, position67)
									}
									if buffer[position] != rune('-') {
										goto l65
									}
									position++
									{
										position69 := position
										if !_rules[ruledigitDual]() {
											goto l65
										}
										add(ruledateMonth, position69)
									}
									if buffer[position] != rune('-') {
										goto l65
									}
									position++
									{
										position70 := position
										if !_rules[ruledigitDual]() {
											goto l65
										}
										add(ruledateMDay, position70)
									}
									add(rulefullDate, position66)
								}
								{
									position71, tokenIndex71 := position, tokenIndex
									{
										position73, tokenIndex73 := position, tokenIndex
										if buffer[position] != rune('T') {
											goto l74
										}
										position++
										goto l73
									l74:
										position, tokenIndex = position73, tokenIndex73
										if buffer[position] != rune(' ') {
											goto l71
										}
										position++
									}
								l73:
									{
										position75 := position
										if !_rules[rulepartialTime]() {
											goto l71
										}
										{
											position76, tokenIndex76 := position, tokenIndex
											{
												position78 := position
												{
													position79, tokenIndex79 := position, tokenIndex
													if buffer[position] != rune('Z') {
														goto l80
													}
													position++
													goto l79
												l80:
													position, tokenIndex = position79, tokenIndex79
													{
														position81 := position
														{
															position82, tokenIndex82 := position, tokenIndex
															if buffer[position] != rune('-') {
																goto l83
															}
															position++
															goto l82
														l83:
															position, tokenIndex = position82, tokenIndex82
															if buffer[position] != rune('+') {
																goto l76
															}
															position++
														}
													l82:
														if !_rules[ruletimeHour]() {
															goto l76
														}
														if buffer[position] != rune(':') {
															goto l76
														}
														position++
														if !_rules[ruletimeMinute]() {
															goto l76
														}
														add(ruletimeNumoffset, position81)
													}
												}
											l79:
												add(ruletimeOffset, position78)
											}
											goto l77
										l76:
											position, tokenIndex = position76, tokenIndex76
										}
									l77:
										add(rulefullTime, position75)
									}
									goto l72
								l71:
									position, tokenIndex = position71, tokenIndex71
								}
							l72:
								goto l64
							l65:
								position, tokenIndex = position64, tokenIndex64
								if !_rules[rulepartialTime]() {
									goto l61
								}
							}
						l64:
							add(ruledatetime, position63)
						}
						add(rulePegText, position62)
					}
					{
						add(ruleAction3, position)
					}
					goto l60
				l61:
					position, tokenIndex = position60, tokenIndex60
					{
						position86 := position
						{
							position87 := position
							{
								position88, tokenIndex88 := position, tokenIndex
								{
									position90, tokenIndex90 := position, tokenIndex
									if buffer[position] != rune('+') {
										goto l91
									}
									position++
									goto l90
								l91:
									position, tokenIndex = position90, tokenIndex90
									if buffer[position] != rune('-') {
										goto l88
									}
									position++
								}
							l90:
								goto l89
							l88:
								position, tokenIndex = position88, tokenIndex88
							}
						l89:
							{
								switch buffer[position] {
								case 'i':
									if buffer[position] != rune('i') {
										goto l85
									}
									position++
									if buffer[position] != rune('n') {
										goto l85
									}
									position++
									if buffer[position] != rune('f') {
										goto l85
									}
									position++
								case 'n':
									if buffer[position] != rune('n') {
										goto l85
									}
									position++
									if buffer[position] != rune('a') {
										goto l85
									}
									position++
									if buffer[position] != rune('n') {
										goto l85
									}
									position++
								default:
									{
										position93 := position
										if !_rules[ruledecimalInt]() {
											goto l85
										}
										{
											position94, tokenIndex94 := position, tokenIndex
											if !_rules[rulefloatFrac]() {
												goto l95
											}
											{
												position96, tokenIndex96 := position, tokenIndex
												if !_rules[rulefloatExp]() {
													goto l96
												}
												goto l97
											l96:
												position, tokenIndex = position96, tokenIndex96
											}
										l97:
											goto l94
										l95:
											position, tokenIndex = position94, tokenIndex94
											{
												position98, tokenIndex98 := position, tokenIndex
												if !_rules[rulefloatFrac]() {
													goto l98
												}
												goto l99
											l98:
												position, tokenIndex = position98, tokenIndex98
											}
										l99:
											if !_rules[rulefloatExp]() {
												goto l85
											}
										}
									l94:
										add(rulefloatDigits, position93)
									}
								}
							}

							add(rulefloat, position87)
						}
						add(rulePegText, position86)
					}
					{
						add(ruleAction4, position)
					}
					goto l60
				l85:
					position, tokenIndex = position60, tokenIndex60
					{
						switch buffer[position] {
						case '{':
							{
								position102 := position
								{
									position103 := position
									if buffer[position] != rune('{') {
										goto l58
									}
									position++
									{
										add(ruleAction12, position)
									}
									if !_rules[rulews]() {
										goto l58
									}
									{
										position105 := position
									l106:
										{
											position107, tokenIndex107 := position, tokenIndex
											if !_rules[rulekeyval]() {
												goto l107
											}
											{
												position108, tokenIndex108 := position, tokenIndex
												{
													position110 := position
													if !_rules[rulews]() {
														goto l108
													}
													if buffer[position] != rune(',') {
														goto l108
													}
													position++
													if !_rules[rulews]() {
														goto l108
													}
													add(ruleinlineTableValSep, position110)
												}
												goto l109
											l108:
												position, tokenIndex = position108, tokenIndex108
											}
										l109:
											goto l106
										l107:
											position, tokenIndex = position107, tokenIndex107
										}
										add(ruleinlineTableKeyValues, position105)
									}
									if !_rules[rulews]() {
										goto l58
									}
									if buffer[position] != rune('}') {
										goto l58
									}
									position++
									{
										add(ruleAction13, position)
									}
									add(ruleinlineTable, position103)
								}
								add(rulePegText, position102)
							}
							{
								add(ruleAction9, position)
							}
						case '[':
							{
								position113 := position
								{
									position114 := position
									if buffer[position] != rune('[') {
										goto l58
									}
									position++
									{
										add(ruleAction24, position)
									}
									if !_rules[rulewsnl]() {
										goto l58
									}
									{
										position116, tokenIndex116 := position, tokenIndex
										{
											position118 := position
											if !_rules[ruleval]() {
												goto l116
											}
											{
												add(ruleAction25, position)
											}
										l120:
											{
												position121, tokenIndex121 := position, tokenIndex
												if !_rules[rulewsnl]() {
													goto l121
												}
												{
													position122, tokenIndex122 := position, tokenIndex
													if !_rules[rulecomment]() {
														goto l122
													}
													goto l123
												l122:
													position, tokenIndex = position122, tokenIndex122
												}
											l123:
												if !_rules[rulewsnl]() {
													goto l121
												}
												if !_rules[rulearraySep]() {
													goto l121
												}
												if !_rules[rulewsnl]() {
													goto l121
												}
												{
													position124, tokenIndex124 := position, tokenIndex
													if !_rules[rulecomment]() {
														goto l124
													}
													goto l125
												l124:
													position, tokenIndex = position124, tokenIndex124
												}
											l125:
												if !_rules[rulewsnl]() {
													goto l121
												}
												if !_rules[ruleval]() {
													goto l121
												}
												{
													add(ruleAction26, position)
												}
												goto l120
											l121:
												position, tokenIndex = position121, tokenIndex121
											}
											if !_rules[rulewsnl]() {
												goto l116
											}
											{
												position127, tokenIndex127 := position, tokenIndex
												if !_rules[rulearraySep]() {
													goto l127
												}
												goto l128
											l127:
												position, tokenIndex = position127, tokenIndex127
											}
										l128:
											if !_rules[rulewsnl]() {
												goto l116
											}
											{
												position129, tokenIndex129 := position, tokenIndex
												if !_rules[rulecomment]() {
													goto l129
												}
												goto l130
											l129:
												position, tokenIndex = position129, tokenIndex129
											}
										l130:
											add(rulearrayValues, position118)
										}
										goto l117
									l116:
										position, tokenIndex = position116, tokenIndex116
									}
								l117:
									if !_rules[rulewsnl]() {
										goto l58
									}
									if buffer[position] != rune(']') {
										goto l58
									}
									position++
									add(rulearray, position114)
								}
								add(rulePegText, position113)
							}
							{
								add(ruleAction8, position)
							}
						case 'f', 't':
							{
								position132 := position
								{
									position133 := position
									{
										position134, tokenIndex134 := position, tokenIndex
										if buffer[position] != rune('t') {
											goto l135
										}
										position++
										if buffer[position] != rune('r') {
											goto l135
										}
										position++
										if buffer[position] != rune('u') {
											goto l135
										}
										position++
										if buffer[position] != rune('e') {
											goto l135
										}
										position++
										goto l134
									l135:
										position, tokenIndex = position134, tokenIndex134
										if buffer[position] != rune('f') {
											goto l58
										}
										position++
										if buffer[position] != rune('a') {
											goto l58
										}
										position++
										if buffer[position] != rune('l') {
											goto l58
										}
										position++
										if buffer[position] != rune('s') {
											goto l58
										}
										position++
										if buffer[position] != rune('e') {
											goto l58
										}
										position++
									}
								l134:
									add(ruleboolean, position133)
								}
								add(rulePegText, position132)
							}
							{
								add(ruleAction7, position)
							}
						case '"', '\'':
							{
								position137 := position
								{
									position138 := position
									{
										position139, tokenIndex139 := position, tokenIndex
										{
											position141 := position
											if buffer[position] != rune('\'') {
												goto l140
											}
											position++
											if buffer[position] != rune('\'') {
												goto l140
											}
											position++
											if buffer[position] != rune('\'') {
												goto l140
											}
											position++
											{
												position142 := position
												{
													position143 := position
												l144:
													{
														position145, tokenIndex145 := position, tokenIndex
														{
															position146, tokenIndex146 := position, tokenIndex
															if buffer[position] != rune('\'') {
																goto l146
															}
															position++
															if buffer[position] != rune('\'') {
																goto l146
															}
															position++
															if buffer[position] != rune('\'') {
																goto l146
															}
															position++
															goto l145
														l146:
															position, tokenIndex = position146, tokenIndex146
														}
														{
															position147, tokenIndex147 := position, tokenIndex
															{
																position149 := position
																{
																	position150, tokenIndex150 := position, tokenIndex
																	if buffer[position] != rune('\t') {
																		goto l151
																	}
																	position++
																	goto l150
																l151:
																	position, tokenIndex = position150, tokenIndex150
																	if c := buffer[position]; c < rune(' ') || c > rune('\U0010ffff') {
																		goto l148
																	}
																	position++
																}
															l150:
																add(rulemlLiteralChar, position149)
															}
															goto l147
														l148:
															position, tokenIndex = position147, tokenIndex147
															if !_rules[rulenewline]() {
																goto l145
															}
														}
													l147:
														goto l144
													l145:
														position, tokenIndex = position145, tokenIndex145
													}
													add(rulemlLiteralBody, position143)
												}
												add(rulePegText, position142)
											}
											if buffer[position] != rune('\'') {
												goto l140
											}
											position++
											if buffer[position] != rune('\'') {
												goto l140
											}
											position++
											if buffer[position] != rune('\'') {
												goto l140
											}
											position++
											{
												add(ruleAction23, position)
											}
											add(rulemlLiteralString, position141)
										}
										goto l139
									l140:
										position, tokenIndex = position139, tokenIndex139
										{
											position154 := position
											if buffer[position] != rune('\'') {
												goto l153
											}
											position++
											{
												position155 := position
											l156:
												{
													position157, tokenIndex157 := position, tokenIndex
													{
														position158 := position
														{
															switch buffer[position] {
															case '\t':
																if buffer[position] != rune('\t') {
																	goto l157
																}
																position++
															case ' ', '!', '"', '#', '$', '%', '&':
																if c := buffer[position]; c < rune(' ') || c > rune('&') {
																	goto l157
																}
																position++
															default:
																if c := buffer[position]; c < rune('(') || c > rune('\U0010ffff') {
																	goto l157
																}
																position++
															}
														}

														add(ruleliteralChar, position158)
													}
													goto l156
												l157:
													position, tokenIndex = position157, tokenIndex157
												}
												add(rulePegText, position155)
											}
											if buffer[position] != rune('\'') {
												goto l153
											}
											position++
											{
												add(ruleAction22, position)
											}
											add(ruleliteralString, position154)
										}
										goto l139
									l153:
										position, tokenIndex = position139, tokenIndex139
										{
											position162 := position
											if buffer[position] != rune('"') {
												goto l161
											}
											position++
											if buffer[position] != rune('"') {
												goto l161
											}
											position++
											if buffer[position] != rune('"') {
												goto l161
											}
											position++
											{
												position163 := position
											l164:
												{
													position165, tokenIndex165 := position, tokenIndex
													{
														position166, tokenIndex166 := position, tokenIndex
														{
															position168, tokenIndex168 := position, tokenIndex
															if buffer[position] != rune('"') {
																goto l168
															}
															position++
															if buffer[position] != rune('"') {
																goto l168
															}
															position++
															if buffer[position] != rune('"') {
																goto l168
															}
															position++
															goto l167
														l168:
															position, tokenIndex = position168, tokenIndex168
														}
														if buffer[position] != rune('"') {
															goto l167
														}
														position++
														{
															add(ruleAction20, position)
														}
														goto l166
													l167:
														position, tokenIndex = position166, tokenIndex166
														{
															position171 := position
															{
																position172, tokenIndex172 := position, tokenIndex
																if !_rules[rulebasicChar]() {
																	goto l173
																}
																goto l172
															l173:
																position, tokenIndex = position172, tokenIndex172
																if !_rules[rulenewline]() {
																	goto l170
																}
															}
														l172:
															add(rulePegText, position171)
														}
														{
															add(ruleAction21, position)
														}
														goto l166
													l170:
														position, tokenIndex = position166, tokenIndex166
														if !_rules[ruleescape]() {
															goto l165
														}
														if !_rules[rulenewline]() {
															goto l165
														}
														if !_rules[rulewsnl]() {
															goto l165
														}
													}
												l166:
													goto l164
												l165:
													position, tokenIndex = position165, tokenIndex165
												}
												add(rulemlBasicBody, position163)
											}
											if buffer[position] != rune('"') {
												goto l161
											}
											position++
											if buffer[position] != rune('"') {
												goto l161
											}
											position++
											if buffer[position] != rune('"') {
												goto l161
											}
											position++
											{
												add(ruleAction19, position)
											}
											add(rulemlBasicString, position162)
										}
										goto l139
									l161:
										position, tokenIndex = position139, tokenIndex139
										{
											position176 := position
											{
												position177 := position
												if buffer[position] != rune('"') {
													goto l58
												}
												position++
											l178:
												{
													position179, tokenIndex179 := position, tokenIndex
													if !_rules[rulebasicChar]() {
														goto l179
													}
													goto l178
												l179:
													position, tokenIndex = position179, tokenIndex179
												}
												if buffer[position] != rune('"') {
													goto l58
												}
												position++
												add(rulePegText, position177)
											}
											{
												add(ruleAction18, position)
											}
											add(rulebasicString, position176)
										}
									}
								l139:
									add(rulestring, position138)
								}
								add(rulePegText, position137)
							}
							{
								add(ruleAction6, position)
							}
						default:
							{
								position182 := position
								{
									position183 := position
									{
										position184, tokenIndex184 := position, tokenIndex
										{
											position186 := position
											if buffer[position] != rune('0') {
												goto l185
											}
											position++
											if buffer[position] != rune('x') {
												goto l185
											}
											position++
											if !_rules[rulehexDigit]() {
												goto l185
											}
										l187:
											{
												position188, tokenIndex188 := position, tokenIndex
												{
													position189, tokenIndex189 := position, tokenIndex
													if !_rules[rulehexDigit]() {
														goto l190
													}
													goto l189
												l190:
													position, tokenIndex = position189, tokenIndex189
													if buffer[position] != rune('_') {
														goto l188
													}
													position++
													if !_rules[rulehexDigit]() {
														goto l188
													}
												}
											l189:
												goto l187
											l188:
												position, tokenIndex = position188, tokenIndex188
											}
											add(rulehexInt, position186)
										}
										goto l184
									l185:
										position, tokenIndex = position184, tokenIndex184
										{
											position192 := position
											if buffer[position] != rune('0') {
												goto l191
											}
											position++
											if buffer[position] != rune('o') {
												goto l191
											}
											position++
											if !_rules[ruleoctalDigit]() {
												goto l191
											}
										l193:
											{
												position194, tokenIndex194 := position, tokenIndex
												{
													position195, tokenIndex195 := position, tokenIndex
													if !_rules[ruleoctalDigit]() {
														goto l196
													}
													goto l195
												l196:
													position, tokenIndex = position195, tokenIndex195
													if buffer[position] != rune('_') {
														goto l194
													}
													position++
													if !_rules[ruleoctalDigit]() {
														goto l194
													}
												}
											l195:
												goto l193
											l194:
												position, tokenIndex = position194, tokenIndex194
											}
											add(ruleoctalInt, position192)
										}
										goto l184
									l191:
										position, tokenIndex = position184, tokenIndex184
										{
											position198 := position
											if buffer[position] != rune('0') {
												goto l197
											}
											position++
											if buffer[position] != rune('b') {
												goto l197
											}
											position++
											if !_rules[rulebinaryDigit]() {
												goto l197
											}
										l199:
											{
												position200, tokenIndex200 := position, tokenIndex
												{
													position201, tokenIndex201 := position, tokenIndex
													if !_rules[rulebinaryDigit]() {
														goto l202
													}
													goto l201
												l202:
													position, tokenIndex = position201, tokenIndex201
													if buffer[position] != rune('_') {
														goto l200
													}
													position++
													if !_rules[ruleoctalDigit]() {
														goto l200
													}
												}
											l201:
												goto l199
											l200:
												position, tokenIndex = position200, tokenIndex200
											}
											add(rulebinaryInt, position198)
										}
										goto l184
									l197:
										position, tokenIndex = position184, tokenIndex184
										if !_rules[ruledecimalInt]() {
											goto l203
										}
										goto l184
									l203:
										position, tokenIndex = position184, tokenIndex184
										{
											position204, tokenIndex204 := position, tokenIndex
											if buffer[position] != rune('+') {
												goto l205
											}
											position++
											goto l204
										l205:
											position, tokenIndex = position204, tokenIndex204
											if buffer[position] != rune('-') {
												goto l58
											}
											position++
										}
									l204:
										if !_rules[ruledecimalInt]() {
											goto l58
										}
									}
								l184:
									add(ruleinteger, position183)
								}
								add(rulePegText, position182)
							}
							{
								add(ruleAction5, position)
							}
						}
					}

				}
			l60:
				add(ruleval, position59)
			}
			return true
		l58:
			position, tokenIndex = position58, tokenIndex58
			return false
		},
		/* 7 table <- <(stdTable / arrayTable)> */
		nil,
		/* 8 stdTable <- <('[' ws <tableKey> ws ']' Action10)> */
		nil,
		/* 9 arrayTable <- <('[' '[' ws <tableKey> ws (']' ']') Action11)> */
		nil,
		/* 10 inlineTable <- <('{' Action12 ws inlineTableKeyValues ws '}' Action13)> */
		nil,
		/* 11 inlineTableKeyValues <- <(keyval inlineTableValSep?)*> */
		nil,
		/* 12 keyval <- <(key ws '=' ws val Action14)> */
		func() bool {
			position212, tokenIndex212 := position, tokenIndex
			{
				position213 := position
				if !_rules[rulekey]() {
					goto l212
				}
				if !_rules[rulews]() {
					goto l212
				}
				if buffer[position] != rune('=') {
					goto l212
				}
				position++
				if !_rules[rulews]() {
					goto l212
				}
				if !_rules[ruleval]() {
					goto l212
				}
				{
					add(ruleAction14, position)
				}
				add(rulekeyval, position213)
			}
			return true
		l212:
			position, tokenIndex = position212, tokenIndex212
			return false
		},
		/* 13 key <- <(bareKey / quotedKey)> */
		func() bool {
			position215, tokenIndex215 := position, tokenIndex
			{
				position216 := position
				{
					position217, tokenIndex217 := position, tokenIndex
					{
						position219 := position
						{
							position220 := position
							{
								switch buffer[position] {
								case '_':
									if buffer[position] != rune('_') {
										goto l218
									}
									position++
								case '-':
									if buffer[position] != rune('-') {
										goto l218
									}
									position++
								case 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z':
									if c := buffer[position]; c < rune('a') || c > rune('z') {
										goto l218
									}
									position++
								case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
									if c := buffer[position]; c < rune('0') || c > rune('9') {
										goto l218
									}
									position++
								default:
									if c := buffer[position]; c < rune('A') || c > rune('Z') {
										goto l218
									}
									position++
								}
							}

						l221:
							{
								position222, tokenIndex222 := position, tokenIndex
								{
									switch buffer[position] {
									case '_':
										if buffer[position] != rune('_') {
											goto l222
										}
										position++
									case '-':
										if buffer[position] != rune('-') {
											goto l222
										}
										position++
									case 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z':
										if c := buffer[position]; c < rune('a') || c > rune('z') {
											goto l222
										}
										position++
									case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
										if c := buffer[position]; c < rune('0') || c > rune('9') {
											goto l222
										}
										position++
									default:
										if c := buffer[position]; c < rune('A') || c > rune('Z') {
											goto l222
										}
										position++
									}
								}

								goto l221
							l222:
								position, tokenIndex = position222, tokenIndex222
							}
							add(rulePegText, position220)
						}
						{
							add(ruleAction15, position)
						}
						add(rulebareKey, position219)
					}
					goto l217
				l218:
					position, tokenIndex = position217, tokenIndex217
					{
						position226 := position
						{
							position227 := position
							if buffer[position] != rune('"') {
								goto l215
							}
							position++
						l228:
							{
								position229, tokenIndex229 := position, tokenIndex
								if !_rules[rulebasicChar]() {
									goto l229
								}
								goto l228
							l229:
								position, tokenIndex = position229, tokenIndex229
							}
							if buffer[position] != rune('"') {
								goto l215
							}
							position++
							add(rulePegText, position227)
						}
						{
							add(ruleAction16, position)
						}
						add(rulequotedKey, position226)
					}
				}
			l217:
				add(rulekey, position216)
			}
			return true
		l215:
			position, tokenIndex = position215, tokenIndex215
			return false
		},
		/* 14 bareKey <- <(<((&('_') '_') | (&('-') '-') | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z]))+> Action15)> */
		nil,
		/* 15 quotedKey <- <(<('"' basicChar* '"')> Action16)> */
		nil,
		/* 16 tableKey <- <(tableKeyComp (tableKeySep tableKeyComp)*)> */
		func() bool {
			position233, tokenIndex233 := position, tokenIndex
			{
				position234 := position
				if !_rules[ruletableKeyComp]() {
					goto l233
				}
			l235:
				{
					position236, tokenIndex236 := position, tokenIndex
					{
						position237 := position
						if !_rules[rulews]() {
							goto l236
						}
						if buffer[position] != rune('.') {
							goto l236
						}
						position++
						if !_rules[rulews]() {
							goto l236
						}
						add(ruletableKeySep, position237)
					}
					if !_rules[ruletableKeyComp]() {
						goto l236
					}
					goto l235
				l236:
					position, tokenIndex = position236, tokenIndex236
				}
				add(ruletableKey, position234)
			}
			return true
		l233:
			position, tokenIndex = position233, tokenIndex233
			return false
		},
		/* 17 tableKeyComp <- <(key Action17)> */
		func() bool {
			position238, tokenIndex238 := position, tokenIndex
			{
				position239 := position
				if !_rules[rulekey]() {
					goto l238
				}
				{
					add(ruleAction17, position)
				}
				add(ruletableKeyComp, position239)
			}
			return true
		l238:
			position, tokenIndex = position238, tokenIndex238
			return false
		},
		/* 18 tableKeySep <- <(ws '.' ws)> */
		nil,
		/* 19 inlineTableValSep <- <(ws ',' ws)> */
		nil,
		/* 20 boolean <- <(('t' 'r' 'u' 'e') / ('f' 'a' 'l' 's' 'e'))> */
		nil,
		/* 21 integer <- <(hexInt / octalInt / binaryInt / decimalInt / (('+' / '-') decimalInt))> */
		nil,
		/* 22 decimalInt <- <(([1-9] (decimalDigit / ('_' decimalDigit))+) / decimalDigit)> */
		func() bool {
			position245, tokenIndex245 := position, tokenIndex
			{
				position246 := position
				{
					position247, tokenIndex247 := position, tokenIndex
					if c := buffer[position]; c < rune('1') || c > rune('9') {
						goto l248
					}
					position++
					{
						position251, tokenIndex251 := position, tokenIndex
						if !_rules[ruledecimalDigit]() {
							goto l252
						}
						goto l251
					l252:
						position, tokenIndex = position251, tokenIndex251
						if buffer[position] != rune('_') {
							goto l248
						}
						position++
						if !_rules[ruledecimalDigit]() {
							goto l248
						}
					}
				l251:
				l249:
					{
						position250, tokenIndex250 := position, tokenIndex
						{
							position253, tokenIndex253 := position, tokenIndex
							if !_rules[ruledecimalDigit]() {
								goto l254
							}
							goto l253
						l254:
							position, tokenIndex = position253, tokenIndex253
							if buffer[position] != rune('_') {
								goto l250
							}
							position++
							if !_rules[ruledecimalDigit]() {
								goto l250
							}
						}
					l253:
						goto l249
					l250:
						position, tokenIndex = position250, tokenIndex250
					}
					goto l247
				l248:
					position, tokenIndex = position247, tokenIndex247
					if !_rules[ruledecimalDigit]() {
						goto l245
					}
				}
			l247:
				add(ruledecimalInt, position246)
			}
			return true
		l245:
			position, tokenIndex = position245, tokenIndex245
			return false
		},
		/* 23 decimalDigit <- <[0-9]> */
		func() bool {
			position255, tokenIndex255 := position, tokenIndex
			{
				position256 := position
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l255
				}
				position++
				add(ruledecimalDigit, position256)
			}
			return true
		l255:
			position, tokenIndex = position255, tokenIndex255
			return false
		},
		/* 24 hexInt <- <('0' 'x' hexDigit (hexDigit / ('_' hexDigit))*)> */
		nil,
		/* 25 hexDigit <- <((&('a' | 'b' | 'c' | 'd' | 'e' | 'f') [a-f]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F') [A-F]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]))> */
		func() bool {
			position258, tokenIndex258 := position, tokenIndex
			{
				position259 := position
				{
					switch buffer[position] {
					case 'a', 'b', 'c', 'd', 'e', 'f':
						if c := buffer[position]; c < rune('a') || c > rune('f') {
							goto l258
						}
						position++
					case 'A', 'B', 'C', 'D', 'E', 'F':
						if c := buffer[position]; c < rune('A') || c > rune('F') {
							goto l258
						}
						position++
					default:
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l258
						}
						position++
					}
				}

				add(rulehexDigit, position259)
			}
			return true
		l258:
			position, tokenIndex = position258, tokenIndex258
			return false
		},
		/* 26 octalInt <- <('0' 'o' octalDigit (octalDigit / ('_' octalDigit))*)> */
		nil,
		/* 27 octalDigit <- <[0-7]> */
		func() bool {
			position262, tokenIndex262 := position, tokenIndex
			{
				position263 := position
				if c := buffer[position]; c < rune('0') || c > rune('7') {
					goto l262
				}
				position++
				add(ruleoctalDigit, position263)
			}
			return true
		l262:
			position, tokenIndex = position262, tokenIndex262
			return false
		},
		/* 28 binaryInt <- <('0' 'b' binaryDigit (binaryDigit / ('_' octalDigit))*)> */
		nil,
		/* 29 binaryDigit <- <('0' / '1')> */
		func() bool {
			position265, tokenIndex265 := position, tokenIndex
			{
				position266 := position
				{
					position267, tokenIndex267 := position, tokenIndex
					if buffer[position] != rune('0') {
						goto l268
					}
					position++
					goto l267
				l268:
					position, tokenIndex = position267, tokenIndex267
					if buffer[position] != rune('1') {
						goto l265
					}
					position++
				}
			l267:
				add(rulebinaryDigit, position266)
			}
			return true
		l265:
			position, tokenIndex = position265, tokenIndex265
			return false
		},
		/* 30 float <- <(('+' / '-')? ((&('i') ('i' 'n' 'f')) | (&('n') ('n' 'a' 'n')) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') floatDigits)))> */
		nil,
		/* 31 floatDigits <- <(decimalInt ((floatFrac floatExp?) / (floatFrac? floatExp)))> */
		nil,
		/* 32 floatFrac <- <('.' decimalDigit (decimalDigit / ('_' decimalDigit))*)> */
		func() bool {
			position271, tokenIndex271 := position, tokenIndex
			{
				position272 := position
				if buffer[position] != rune('.') {
					goto l271
				}
				position++
				if !_rules[ruledecimalDigit]() {
					goto l271
				}
			l273:
				{
					position274, tokenIndex274 := position, tokenIndex
					{
						position275, tokenIndex275 := position, tokenIndex
						if !_rules[ruledecimalDigit]() {
							goto l276
						}
						goto l275
					l276:
						position, tokenIndex = position275, tokenIndex275
						if buffer[position] != rune('_') {
							goto l274
						}
						position++
						if !_rules[ruledecimalDigit]() {
							goto l274
						}
					}
				l275:
					goto l273
				l274:
					position, tokenIndex = position274, tokenIndex274
				}
				add(rulefloatFrac, position272)
			}
			return true
		l271:
			position, tokenIndex = position271, tokenIndex271
			return false
		},
		/* 33 floatExp <- <(('e' / 'E') ('-' / '+')? decimalDigit (decimalDigit / ('_' decimalDigit))*)> */
		func() bool {
			position277, tokenIndex277 := position, tokenIndex
			{
				position278 := position
				{
					position279, tokenIndex279 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l280
					}
					position++
					goto l279
				l280:
					position, tokenIndex = position279, tokenIndex279
					if buffer[position] != rune('E') {
						goto l277
					}
					position++
				}
			l279:
				{
					position281, tokenIndex281 := position, tokenIndex
					{
						position283, tokenIndex283 := position, tokenIndex
						if buffer[position] != rune('-') {
							goto l284
						}
						position++
						goto l283
					l284:
						position, tokenIndex = position283, tokenIndex283
						if buffer[position] != rune('+') {
							goto l281
						}
						position++
					}
				l283:
					goto l282
				l281:
					position, tokenIndex = position281, tokenIndex281
				}
			l282:
				if !_rules[ruledecimalDigit]() {
					goto l277
				}
			l285:
				{
					position286, tokenIndex286 := position, tokenIndex
					{
						position287, tokenIndex287 := position, tokenIndex
						if !_rules[ruledecimalDigit]() {
							goto l288
						}
						goto l287
					l288:
						position, tokenIndex = position287, tokenIndex287
						if buffer[position] != rune('_') {
							goto l286
						}
						position++
						if !_rules[ruledecimalDigit]() {
							goto l286
						}
					}
				l287:
					goto l285
				l286:
					position, tokenIndex = position286, tokenIndex286
				}
				add(rulefloatExp, position278)
			}
			return true
		l277:
			position, tokenIndex = position277, tokenIndex277
			return false
		},
		/* 34 escaped <- <(escape ((&('U') ('U' hexQuad hexQuad)) | (&('u') ('u' hexQuad)) | (&('\\') '\\') | (&('/') '/') | (&('"') '"') | (&('r') 'r') | (&('f') 'f') | (&('n') 'n') | (&('t') 't') | (&('b') 'b')))> */
		nil,
		/* 35 escape <- <'\\'> */
		func() bool {
			position290, tokenIndex290 := position, tokenIndex
			{
				position291 := position
				if buffer[position] != rune('\\') {
					goto l290
				}
				position++
				add(ruleescape, position291)
			}
			return true
		l290:
			position, tokenIndex = position290, tokenIndex290
			return false
		},
		/* 36 hexQuad <- <(hexDigit hexDigit hexDigit hexDigit)> */
		func() bool {
			position292, tokenIndex292 := position, tokenIndex
			{
				position293 := position
				if !_rules[rulehexDigit]() {
					goto l292
				}
				if !_rules[rulehexDigit]() {
					goto l292
				}
				if !_rules[rulehexDigit]() {
					goto l292
				}
				if !_rules[rulehexDigit]() {
					goto l292
				}
				add(rulehexQuad, position293)
			}
			return true
		l292:
			position, tokenIndex = position292, tokenIndex292
			return false
		},
		/* 37 string <- <(mlLiteralString / literalString / mlBasicString / basicString)> */
		nil,
		/* 38 basicString <- <(<('"' basicChar* '"')> Action18)> */
		nil,
		/* 39 basicChar <- <(basicUnescaped / escaped)> */
		func() bool {
			position296, tokenIndex296 := position, tokenIndex
			{
				position297 := position
				{
					position298, tokenIndex298 := position, tokenIndex
					{
						position300 := position
						{
							switch buffer[position] {
							case '\t':
								if buffer[position] != rune('\t') {
									goto l299
								}
								position++
							case ' ', '!':
								if c := buffer[position]; c < rune(' ') || c > rune('!') {
									goto l299
								}
								position++
							case '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[':
								if c := buffer[position]; c < rune('#') || c > rune('[') {
									goto l299
								}
								position++
							default:
								if c := buffer[position]; c < rune(']') || c > rune('\U0010ffff') {
									goto l299
								}
								position++
							}
						}

						add(rulebasicUnescaped, position300)
					}
					goto l298
				l299:
					position, tokenIndex = position298, tokenIndex298
					{
						position302 := position
						if !_rules[ruleescape]() {
							goto l296
						}
						{
							switch buffer[position] {
							case 'U':
								if buffer[position] != rune('U') {
									goto l296
								}
								position++
								if !_rules[rulehexQuad]() {
									goto l296
								}
								if !_rules[rulehexQuad]() {
									goto l296
								}
							case 'u':
								if buffer[position] != rune('u') {
									goto l296
								}
								position++
								if !_rules[rulehexQuad]() {
									goto l296
								}
							case '\\':
								if buffer[position] != rune('\\') {
									goto l296
								}
								position++
							case '/':
								if buffer[position] != rune('/') {
									goto l296
								}
								position++
							case '"':
								if buffer[position] != rune('"') {
									goto l296
								}
								position++
							case 'r':
								if buffer[position] != rune('r') {
									goto l296
								}
								position++
							case 'f':
								if buffer[position] != rune('f') {
									goto l296
								}
								position++
							case 'n':
								if buffer[position] != rune('n') {
									goto l296
								}
								position++
							case 't':
								if buffer[position] != rune('t') {
									goto l296
								}
								position++
							default:
								if buffer[position] != rune('b') {
									goto l296
								}
								position++
							}
						}

						add(ruleescaped, position302)
					}
				}
			l298:
				add(rulebasicChar, position297)
			}
			return true
		l296:
			position, tokenIndex = position296, tokenIndex296
			return false
		},
		/* 40 basicUnescaped <- <((&('\t') '\t') | (&(' ' | '!') [ -!]) | (&('#' | '$' | '%' | '&' | '\'' | '(' | ')' | '*' | '+' | ',' | '-' | '.' | '/' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | ':' | ';' | '<' | '=' | '>' | '?' | '@' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | '[') [#-[]) | (&(']' | '^' | '_' | '`' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' | '{' | '|' | '}' | '~' | '\u007f' | '\u0080' | '\u0081' | '\u0082' | '\u0083' | '\u0084' | '\u0085' | '\u0086' | '\u0087' | '\u0088' | '\u0089' | '\u008a' | '\u008b' | '\u008c' | '\u008d' | '\u008e' | '\u008f' | '\u0090' | '\u0091' | '\u0092' | '\u0093' | '\u0094' | '\u0095' | '\u0096' | '\u0097' | '\u0098' | '\u0099' | '\u009a' | '\u009b' | '\u009c' | '\u009d' | '\u009e' | '\u009f' | '\u00a0' | '¡' | '¢' | '£' | '¤' | '¥' | '¦' | '§' | '¨' | '©' | 'ª' | '«' | '¬' | '\u00ad' | '®' | '¯' | '°' | '±' | '²' | '³' | '´' | 'µ' | '¶' | '·' | '¸' | '¹' | 'º' | '»' | '¼' | '½' | '¾' | '¿' | 'À' | 'Á' | 'Â' | 'Ã' | 'Ä' | 'Å' | 'Æ' | 'Ç' | 'È' | 'É' | 'Ê' | 'Ë' | 'Ì' | 'Í' | 'Î' | 'Ï' | 'Ð' | 'Ñ' | 'Ò' | 'Ó' | 'Ô' | 'Õ' | 'Ö' | '×' | 'Ø' | 'Ù' | 'Ú' | 'Û' | 'Ü' | 'Ý' | 'Þ' | 'ß' | 'à' | 'á' | 'â' | 'ã' | 'ä' | 'å' | 'æ' | 'ç' | 'è' | 'é' | 'ê' | 'ë' | 'ì' | 'í' | 'î' | 'ï' | 'ð' | 'ñ' | 'ò' | 'ó' | 'ô' | 'õ' | 'ö' | '÷' | 'ø' | 'ù' | 'ú' | 'û' | 'ü' | 'ý' | 'þ' | 'ÿ') []-\U0010ffff]))> */
		nil,
		/* 41 mlBasicString <- <('"' '"' '"' mlBasicBody ('"' '"' '"') Action19)> */
		nil,
		/* 42 mlBasicBody <- <((!('"' '"' '"') '"' Action20) / (<(basicChar / newline)> Action21) / (escape newline wsnl))*> */
		nil,
		/* 43 literalString <- <('\'' <literalChar*> '\'' Action22)> */
		nil,
		/* 44 literalChar <- <((&('\t') '\t') | (&(' ' | '!' | '"' | '#' | '$' | '%' | '&') [ -&]) | (&('(' | ')' | '*' | '+' | ',' | '-' | '.' | '/' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | ':' | ';' | '<' | '=' | '>' | '?' | '@' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | '[' | '\\' | ']' | '^' | '_' | '`' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' | '{' | '|' | '}' | '~' | '\u007f' | '\u0080' | '\u0081' | '\u0082' | '\u0083' | '\u0084' | '\u0085' | '\u0086' | '\u0087' | '\u0088' | '\u0089' | '\u008a' | '\u008b' | '\u008c' | '\u008d' | '\u008e' | '\u008f' | '\u0090' | '\u0091' | '\u0092' | '\u0093' | '\u0094' | '\u0095' | '\u0096' | '\u0097' | '\u0098' | '\u0099' | '\u009a' | '\u009b' | '\u009c' | '\u009d' | '\u009e' | '\u009f' | '\u00a0' | '¡' | '¢' | '£' | '¤' | '¥' | '¦' | '§' | '¨' | '©' | 'ª' | '«' | '¬' | '\u00ad' | '®' | '¯' | '°' | '±' | '²' | '³' | '´' | 'µ' | '¶' | '·' | '¸' | '¹' | 'º' | '»' | '¼' | '½' | '¾' | '¿' | 'À' | 'Á' | 'Â' | 'Ã' | 'Ä' | 'Å' | 'Æ' | 'Ç' | 'È' | 'É' | 'Ê' | 'Ë' | 'Ì' | 'Í' | 'Î' | 'Ï' | 'Ð' | 'Ñ' | 'Ò' | 'Ó' | 'Ô' | 'Õ' | 'Ö' | '×' | 'Ø' | 'Ù' | 'Ú' | 'Û' | 'Ü' | 'Ý' | 'Þ' | 'ß' | 'à' | 'á' | 'â' | 'ã' | 'ä' | 'å' | 'æ' | 'ç' | 'è' | 'é' | 'ê' | 'ë' | 'ì' | 'í' | 'î' | 'ï' | 'ð' | 'ñ' | 'ò' | 'ó' | 'ô' | 'õ' | 'ö' | '÷' | 'ø' | 'ù' | 'ú' | 'û' | 'ü' | 'ý' | 'þ' | 'ÿ') [(-\U0010ffff]))> */
		nil,
		/* 45 mlLiteralString <- <('\'' '\'' '\'' <mlLiteralBody> ('\'' '\'' '\'') Action23)> */
		nil,
		/* 46 mlLiteralBody <- <(!('\'' '\'' '\'') (mlLiteralChar / newline))*> */
		nil,
		/* 47 mlLiteralChar <- <('\t' / [ -\U0010ffff])> */
		nil,
		/* 48 dateFullYear <- <digitQuad> */
		nil,
		/* 49 dateMonth <- <digitDual> */
		nil,
		/* 50 dateMDay <- <digitDual> */
		nil,
		/* 51 timeHour <- <digitDual> */
		func() bool {
			position315, tokenIndex315 := position, tokenIndex
			{
				position316 := position
				if !_rules[ruledigitDual]() {
					goto l315
				}
				add(ruletimeHour, position316)
			}
			return true
		l315:
			position, tokenIndex = position315, tokenIndex315
			return false
		},
		/* 52 timeMinute <- <digitDual> */
		func() bool {
			position317, tokenIndex317 := position, tokenIndex
			{
				position318 := position
				if !_rules[ruledigitDual]() {
					goto l317
				}
				add(ruletimeMinute, position318)
			}
			return true
		l317:
			position, tokenIndex = position317, tokenIndex317
			return false
		},
		/* 53 timeSecond <- <digitDual> */
		nil,
		/* 54 timeSecfrac <- <('.' decimalDigit+)> */
		nil,
		/* 55 timeNumoffset <- <(('-' / '+') timeHour ':' timeMinute)> */
		nil,
		/* 56 timeOffset <- <('Z' / timeNumoffset)> */
		nil,
		/* 57 partialTime <- <(timeHour ':' timeMinute ':' timeSecond timeSecfrac?)> */
		func() bool {
			position323, tokenIndex323 := position, tokenIndex
			{
				position324 := position
				if !_rules[ruletimeHour]() {
					goto l323
				}
				if buffer[position] != rune(':') {
					goto l323
				}
				position++
				if !_rules[ruletimeMinute]() {
					goto l323
				}
				if buffer[position] != rune(':') {
					goto l323
				}
				position++
				{
					position325 := position
					if !_rules[ruledigitDual]() {
						goto l323
					}
					add(ruletimeSecond, position325)
				}
				{
					position326, tokenIndex326 := position, tokenIndex
					{
						position328 := position
						if buffer[position] != rune('.') {
							goto l326
						}
						position++
						if !_rules[ruledecimalDigit]() {
							goto l326
						}
					l329:
						{
							position330, tokenIndex330 := position, tokenIndex
							if !_rules[ruledecimalDigit]() {
								goto l330
							}
							goto l329
						l330:
							position, tokenIndex = position330, tokenIndex330
						}
						add(ruletimeSecfrac, position328)
					}
					goto l327
				l326:
					position, tokenIndex = position326, tokenIndex326
				}
			l327:
				add(rulepartialTime, position324)
			}
			return true
		l323:
			position, tokenIndex = position323, tokenIndex323
			return false
		},
		/* 58 fullDate <- <(dateFullYear '-' dateMonth '-' dateMDay)> */
		nil,
		/* 59 fullTime <- <(partialTime timeOffset?)> */
		nil,
		/* 60 datetime <- <((fullDate (('T' / ' ') fullTime)?) / partialTime)> */
		nil,
		/* 61 digitDual <- <(decimalDigit decimalDigit)> */
		func() bool {
			position334, tokenIndex334 := position, tokenIndex
			{
				position335 := position
				if !_rules[ruledecimalDigit]() {
					goto l334
				}
				if !_rules[ruledecimalDigit]() {
					goto l334
				}
				add(ruledigitDual, position335)
			}
			return true
		l334:
			position, tokenIndex = position334, tokenIndex334
			return false
		},
		/* 62 digitQuad <- <(digitDual digitDual)> */
		nil,
		/* 63 array <- <('[' Action24 wsnl arrayValues? wsnl ']')> */
		nil,
		/* 64 arrayValues <- <(val Action25 (wsnl comment? wsnl arraySep wsnl comment? wsnl val Action26)* wsnl arraySep? wsnl comment?)> */
		nil,
		/* 65 arraySep <- <','> */
		func() bool {
			position339, tokenIndex339 := position, tokenIndex
			{
				position340 := position
				if buffer[position] != rune(',') {
					goto l339
				}
				position++
				add(rulearraySep, position340)
			}
			return true
		l339:
			position, tokenIndex = position339, tokenIndex339
			return false
		},
		/* 67 Action0 <- <{ _ = buffer }> */
		nil,
		nil,
		/* 69 Action1 <- <{ p.SetTableSource(begin, end) }> */
		nil,
		/* 70 Action2 <- <{ p.Newline() }> */
		nil,
		/* 71 Action3 <- <{ p.SetTime(begin, end) }> */
		nil,
		/* 72 Action4 <- <{ p.SetFloat(begin, end) }> */
		nil,
		/* 73 Action5 <- <{ p.SetInteger(begin, end) }> */
		nil,
		/* 74 Action6 <- <{ p.SetString(begin, end) }> */
		nil,
		/* 75 Action7 <- <{ p.SetBool(begin, end) }> */
		nil,
		/* 76 Action8 <- <{ p.SetArray(begin, end) }> */
		nil,
		/* 77 Action9 <- <{ p.SetInlineTableSource(begin, end) }> */
		nil,
		/* 78 Action10 <- <{ p.SetTable(p.buffer, begin, end) }> */
		nil,
		/* 79 Action11 <- <{ p.SetArrayTable(p.buffer, begin, end) }> */
		nil,
		/* 80 Action12 <- <{ p.StartInlineTable() }> */
		nil,
		/* 81 Action13 <- <{ p.EndInlineTable() }> */
		nil,
		/* 82 Action14 <- <{ p.AddKeyValue() }> */
		nil,
		/* 83 Action15 <- <{ p.SetKey(p.buffer, begin, end) }> */
		nil,
		/* 84 Action16 <- <{ p.SetKey(p.buffer, begin, end) }> */
		nil,
		/* 85 Action17 <- <{ p.AddTableKey() }> */
		nil,
		/* 86 Action18 <- <{ p.SetBasicString(p.buffer, begin, end) }> */
		nil,
		/* 87 Action19 <- <{ p.SetMultilineBasicString() }> */
		nil,
		/* 88 Action20 <- <{ p.AddMultilineBasicQuote() }> */
		nil,
		/* 89 Action21 <- <{ p.AddMultilineBasicBody(p.buffer, begin, end) }> */
		nil,
		/* 90 Action22 <- <{ p.SetLiteralString(p.buffer, begin, end) }> */
		nil,
		/* 91 Action23 <- <{ p.SetMultilineLiteralString(p.buffer, begin, end) }> */
		nil,
		/* 92 Action24 <- <{ p.StartArray() }> */
		nil,
		/* 93 Action25 <- <{ p.AddArrayVal() }> */
		nil,
		/* 94 Action26 <- <{ p.AddArrayVal() }> */
		nil,
	}
	p.rules = _rules
	return nil
}
