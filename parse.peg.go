package toml

// Code generated by peg -switch -inline parse.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleTOML
	ruleExpression
	ruleval
	rulews
	rulewsnl
	rulecomment
	rulenewline
	rulenewlineRequired
	rulebadControl
	ruletable
	rulestdTable
	rulearrayTable
	rulekeyval
	rulekey
	rulebareKey
	rulebareKeyChar
	rulequotedKey
	ruletableKey
	ruletableKeyComp
	ruletableKeySep
	ruleinlineTable
	ruleinlineTableKeyValues
	ruleinlineTableCommaForbidden
	ruleinlineTableCommaRequired
	ruleboolean
	ruleinteger
	ruledecimalInt
	ruledecimalDigit
	rulehexInt
	rulehexDigit
	ruleoctalInt
	ruleoctalDigit
	rulebinaryInt
	rulebinaryDigit
	rulefloat
	rulefloatDigits
	rulefloatFrac
	rulefloatExp
	ruleescaped
	ruleescape
	rulehexQuad
	rulestring
	rulebasicString
	rulebasicChar
	rulebasicUnescaped
	rulemlBasicString
	rulemlBasicBody
	rulemlBasicBodyChar
	rulemlBasicBodyEndQuotes
	ruleliteralString
	ruleliteralChar
	rulemlLiteralString
	rulemlLiteralBody
	rulemlLiteralChar
	rulemlLiteralBodyEndQuotes
	ruledatetime
	rulepartialTime
	rulefullDate
	rulefullTime
	ruledateFullYear
	ruledateMonth
	ruledateMDay
	ruletimeHour
	ruletimeMinute
	ruletimeSecond
	ruletimeSecfrac
	ruletimeNumoffset
	ruletimeOffset
	ruledigitDual
	ruledigitQuad
	rulearray
	rulearrayValues
	rulearraySep
	ruleAction0
	rulePegText
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
	ruleAction27
	ruleAction28
	ruleAction29
	ruleAction30
	ruleAction31
	ruleAction32
)

var rul3s = [...]string{
	"Unknown",
	"TOML",
	"Expression",
	"val",
	"ws",
	"wsnl",
	"comment",
	"newline",
	"newlineRequired",
	"badControl",
	"table",
	"stdTable",
	"arrayTable",
	"keyval",
	"key",
	"bareKey",
	"bareKeyChar",
	"quotedKey",
	"tableKey",
	"tableKeyComp",
	"tableKeySep",
	"inlineTable",
	"inlineTableKeyValues",
	"inlineTableCommaForbidden",
	"inlineTableCommaRequired",
	"boolean",
	"integer",
	"decimalInt",
	"decimalDigit",
	"hexInt",
	"hexDigit",
	"octalInt",
	"octalDigit",
	"binaryInt",
	"binaryDigit",
	"float",
	"floatDigits",
	"floatFrac",
	"floatExp",
	"escaped",
	"escape",
	"hexQuad",
	"string",
	"basicString",
	"basicChar",
	"basicUnescaped",
	"mlBasicString",
	"mlBasicBody",
	"mlBasicBodyChar",
	"mlBasicBodyEndQuotes",
	"literalString",
	"literalChar",
	"mlLiteralString",
	"mlLiteralBody",
	"mlLiteralChar",
	"mlLiteralBodyEndQuotes",
	"datetime",
	"partialTime",
	"fullDate",
	"fullTime",
	"dateFullYear",
	"dateMonth",
	"dateMDay",
	"timeHour",
	"timeMinute",
	"timeSecond",
	"timeSecfrac",
	"timeNumoffset",
	"timeOffset",
	"digitDual",
	"digitQuad",
	"array",
	"arrayValues",
	"arraySep",
	"Action0",
	"PegText",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
	"Action27",
	"Action28",
	"Action29",
	"Action30",
	"Action31",
	"Action32",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type tomlParser struct {
	toml

	Buffer string
	buffer []rune
	rules  [108]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *tomlParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *tomlParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *tomlParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *tomlParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *tomlParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *tomlParser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func (p *tomlParser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:
			_ = buffer
		case ruleAction1:
			p.SetTableSource(begin, end)
		case ruleAction2:
			p.SetTime(begin, end)
		case ruleAction3:
			p.SetFloat(begin, end)
		case ruleAction4:
			p.SetInteger(begin, end)
		case ruleAction5:
			p.SetString(begin, end)
		case ruleAction6:
			p.SetBool(begin, end)
		case ruleAction7:
			p.SetArray(begin, end)
		case ruleAction8:
			p.SetInlineTableSource(begin, end)
		case ruleAction9:
			p.Newline()
		case ruleAction10:
			p.Error(errNewlineRequired)
		case ruleAction11:

			p.Error(&rawControlError{p.buffer[begin]})

		case ruleAction12:
			p.SetTable(p.buffer, begin, end)
		case ruleAction13:
			p.SetArrayTable(p.buffer, begin, end)
		case ruleAction14:
			p.AddKeyValue()
		case ruleAction15:
			p.SetKey(p.buffer, begin, end)
		case ruleAction16:
			p.SetKey(p.buffer, begin, end)
		case ruleAction17:
			p.AddTableKey()
		case ruleAction18:
			p.StartInlineTable()
		case ruleAction19:
			p.EndInlineTable()
		case ruleAction20:
			p.Error(errInlineTableCommaAtEnd)
		case ruleAction21:
			p.Error(errInlineTableCommaRequired)
		case ruleAction22:
			p.SetBasicString(p.buffer, begin, end)
		case ruleAction23:
			p.SetMultilineBasicString()
		case ruleAction24:
			p.AddMultilineBasicQuote()
		case ruleAction25:
			p.AddMultilineBasicBody(p.buffer, begin, end)
		case ruleAction26:
			p.AddMultilineBasicQuote()
			p.AddMultilineBasicQuote()
		case ruleAction27:
			p.AddMultilineBasicQuote()
		case ruleAction28:
			p.SetLiteralString(p.buffer, begin, end)
		case ruleAction29:
			p.SetMultilineLiteralString(p.buffer, begin, end)
		case ruleAction30:
			p.StartArray()
		case ruleAction31:
			p.AddArrayVal()
		case ruleAction32:
			p.AddArrayVal()

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*tomlParser) error {
	return func(p *tomlParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*tomlParser) error {
	return func(p *tomlParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *tomlParser) Init(options ...func(*tomlParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 TOML <- <(Expression (newline Expression)* newline* !. Action0)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[ruleExpression]() {
					goto l0
				}
			l2:
				{
					position3, tokenIndex3 := position, tokenIndex
					if !_rules[rulenewline]() {
						goto l3
					}
					if !_rules[ruleExpression]() {
						goto l3
					}
					goto l2
				l3:
					position, tokenIndex = position3, tokenIndex3
				}
			l4:
				{
					position5, tokenIndex5 := position, tokenIndex
					if !_rules[rulenewline]() {
						goto l5
					}
					goto l4
				l5:
					position, tokenIndex = position5, tokenIndex5
				}
				{
					position6, tokenIndex6 := position, tokenIndex
					if !matchDot() {
						goto l6
					}
					goto l0
				l6:
					position, tokenIndex = position6, tokenIndex6
				}
				{
					add(ruleAction0, position)
				}
				add(ruleTOML, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 Expression <- <((<(ws table ws comment? (ws newlineRequired wsnl keyval ws comment?)*)> Action1) / (ws keyval ws comment?) / (ws comment?) / ws)> */
		func() bool {
			position8, tokenIndex8 := position, tokenIndex
			{
				position9 := position
				{
					position10, tokenIndex10 := position, tokenIndex
					{
						position12 := position
						if !_rules[rulews]() {
							goto l11
						}
						{
							position13 := position
							{
								position14, tokenIndex14 := position, tokenIndex
								{
									position16 := position
									if buffer[position] != rune('[') {
										goto l15
									}
									position++
									if !_rules[rulews]() {
										goto l15
									}
									{
										position17 := position
										if !_rules[ruletableKey]() {
											goto l15
										}
										add(rulePegText, position17)
									}
									if !_rules[rulews]() {
										goto l15
									}
									if buffer[position] != rune(']') {
										goto l15
									}
									position++
									{
										add(ruleAction12, position)
									}
									add(rulestdTable, position16)
								}
								goto l14
							l15:
								position, tokenIndex = position14, tokenIndex14
								{
									position19 := position
									if buffer[position] != rune('[') {
										goto l11
									}
									position++
									if buffer[position] != rune('[') {
										goto l11
									}
									position++
									if !_rules[rulews]() {
										goto l11
									}
									{
										position20 := position
										if !_rules[ruletableKey]() {
											goto l11
										}
										add(rulePegText, position20)
									}
									if !_rules[rulews]() {
										goto l11
									}
									if buffer[position] != rune(']') {
										goto l11
									}
									position++
									if buffer[position] != rune(']') {
										goto l11
									}
									position++
									{
										add(ruleAction13, position)
									}
									add(rulearrayTable, position19)
								}
							}
						l14:
							add(ruletable, position13)
						}
						if !_rules[rulews]() {
							goto l11
						}
						{
							position22, tokenIndex22 := position, tokenIndex
							if !_rules[rulecomment]() {
								goto l22
							}
							goto l23
						l22:
							position, tokenIndex = position22, tokenIndex22
						}
					l23:
					l24:
						{
							position25, tokenIndex25 := position, tokenIndex
							if !_rules[rulews]() {
								goto l25
							}
							{
								position26 := position
								{
									position27, tokenIndex27 := position, tokenIndex
									{
										position29, tokenIndex29 := position, tokenIndex
										if !_rules[rulenewline]() {
											goto l29
										}
										goto l28
									l29:
										position, tokenIndex = position29, tokenIndex29
									}
									{
										add(ruleAction10, position)
									}
									goto l27
								l28:
									position, tokenIndex = position27, tokenIndex27
									if !_rules[rulenewline]() {
										goto l25
									}
								}
							l27:
								add(rulenewlineRequired, position26)
							}
							if !_rules[rulewsnl]() {
								goto l25
							}
							if !_rules[rulekeyval]() {
								goto l25
							}
							if !_rules[rulews]() {
								goto l25
							}
							{
								position31, tokenIndex31 := position, tokenIndex
								if !_rules[rulecomment]() {
									goto l31
								}
								goto l32
							l31:
								position, tokenIndex = position31, tokenIndex31
							}
						l32:
							goto l24
						l25:
							position, tokenIndex = position25, tokenIndex25
						}
						add(rulePegText, position12)
					}
					{
						add(ruleAction1, position)
					}
					goto l10
				l11:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[rulews]() {
						goto l34
					}
					if !_rules[rulekeyval]() {
						goto l34
					}
					if !_rules[rulews]() {
						goto l34
					}
					{
						position35, tokenIndex35 := position, tokenIndex
						if !_rules[rulecomment]() {
							goto l35
						}
						goto l36
					l35:
						position, tokenIndex = position35, tokenIndex35
					}
				l36:
					goto l10
				l34:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[rulews]() {
						goto l37
					}
					{
						position38, tokenIndex38 := position, tokenIndex
						if !_rules[rulecomment]() {
							goto l38
						}
						goto l39
					l38:
						position, tokenIndex = position38, tokenIndex38
					}
				l39:
					goto l10
				l37:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[rulews]() {
						goto l8
					}
				}
			l10:
				add(ruleExpression, position9)
			}
			return true
		l8:
			position, tokenIndex = position8, tokenIndex8
			return false
		},
		/* 2 val <- <((<datetime> Action2) / (<float> Action3) / ((&('{') (<inlineTable> Action8)) | (&('[') (<array> Action7)) | (&('f' | 't') (<boolean> Action6)) | (&('"' | '\'') (<string> Action5)) | (&('+' | '-' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') (<integer> Action4))))> */
		func() bool {
			position40, tokenIndex40 := position, tokenIndex
			{
				position41 := position
				{
					position42, tokenIndex42 := position, tokenIndex
					{
						position44 := position
						{
							position45 := position
							{
								position46, tokenIndex46 := position, tokenIndex
								{
									position48 := position
									{
										position49 := position
										{
											position50 := position
											if !_rules[ruledigitDual]() {
												goto l47
											}
											if !_rules[ruledigitDual]() {
												goto l47
											}
											add(ruledigitQuad, position50)
										}
										add(ruledateFullYear, position49)
									}
									if buffer[position] != rune('-') {
										goto l47
									}
									position++
									{
										position51 := position
										if !_rules[ruledigitDual]() {
											goto l47
										}
										add(ruledateMonth, position51)
									}
									if buffer[position] != rune('-') {
										goto l47
									}
									position++
									{
										position52 := position
										if !_rules[ruledigitDual]() {
											goto l47
										}
										add(ruledateMDay, position52)
									}
									add(rulefullDate, position48)
								}
								{
									position53, tokenIndex53 := position, tokenIndex
									{
										switch buffer[position] {
										case ' ':
											if buffer[position] != rune(' ') {
												goto l53
											}
											position++
										case 'T':
											if buffer[position] != rune('T') {
												goto l53
											}
											position++
										default:
											if buffer[position] != rune('t') {
												goto l53
											}
											position++
										}
									}

									{
										position56 := position
										if !_rules[rulepartialTime]() {
											goto l53
										}
										{
											position57, tokenIndex57 := position, tokenIndex
											{
												position59 := position
												{
													switch buffer[position] {
													case 'Z':
														if buffer[position] != rune('Z') {
															goto l57
														}
														position++
													case 'z':
														if buffer[position] != rune('z') {
															goto l57
														}
														position++
													default:
														{
															position61 := position
															{
																position62, tokenIndex62 := position, tokenIndex
																if buffer[position] != rune('-') {
																	goto l63
																}
																position++
																goto l62
															l63:
																position, tokenIndex = position62, tokenIndex62
																if buffer[position] != rune('+') {
																	goto l57
																}
																position++
															}
														l62:
															if !_rules[ruletimeHour]() {
																goto l57
															}
															if buffer[position] != rune(':') {
																goto l57
															}
															position++
															if !_rules[ruletimeMinute]() {
																goto l57
															}
															add(ruletimeNumoffset, position61)
														}
													}
												}

												add(ruletimeOffset, position59)
											}
											goto l58
										l57:
											position, tokenIndex = position57, tokenIndex57
										}
									l58:
										add(rulefullTime, position56)
									}
									goto l54
								l53:
									position, tokenIndex = position53, tokenIndex53
								}
							l54:
								goto l46
							l47:
								position, tokenIndex = position46, tokenIndex46
								if !_rules[rulepartialTime]() {
									goto l43
								}
							}
						l46:
							add(ruledatetime, position45)
						}
						add(rulePegText, position44)
					}
					{
						add(ruleAction2, position)
					}
					goto l42
				l43:
					position, tokenIndex = position42, tokenIndex42
					{
						position66 := position
						{
							position67 := position
							{
								position68, tokenIndex68 := position, tokenIndex
								{
									position70, tokenIndex70 := position, tokenIndex
									if buffer[position] != rune('+') {
										goto l71
									}
									position++
									goto l70
								l71:
									position, tokenIndex = position70, tokenIndex70
									if buffer[position] != rune('-') {
										goto l68
									}
									position++
								}
							l70:
								goto l69
							l68:
								position, tokenIndex = position68, tokenIndex68
							}
						l69:
							{
								switch buffer[position] {
								case 'i':
									if buffer[position] != rune('i') {
										goto l65
									}
									position++
									if buffer[position] != rune('n') {
										goto l65
									}
									position++
									if buffer[position] != rune('f') {
										goto l65
									}
									position++
								case 'n':
									if buffer[position] != rune('n') {
										goto l65
									}
									position++
									if buffer[position] != rune('a') {
										goto l65
									}
									position++
									if buffer[position] != rune('n') {
										goto l65
									}
									position++
								default:
									{
										position73 := position
										if !_rules[ruledecimalInt]() {
											goto l65
										}
										{
											position74, tokenIndex74 := position, tokenIndex
											if !_rules[rulefloatFrac]() {
												goto l75
											}
											{
												position76, tokenIndex76 := position, tokenIndex
												if !_rules[rulefloatExp]() {
													goto l76
												}
												goto l77
											l76:
												position, tokenIndex = position76, tokenIndex76
											}
										l77:
											goto l74
										l75:
											position, tokenIndex = position74, tokenIndex74
											{
												position78, tokenIndex78 := position, tokenIndex
												if !_rules[rulefloatFrac]() {
													goto l78
												}
												goto l79
											l78:
												position, tokenIndex = position78, tokenIndex78
											}
										l79:
											if !_rules[rulefloatExp]() {
												goto l65
											}
										}
									l74:
										add(rulefloatDigits, position73)
									}
								}
							}

							add(rulefloat, position67)
						}
						add(rulePegText, position66)
					}
					{
						add(ruleAction3, position)
					}
					goto l42
				l65:
					position, tokenIndex = position42, tokenIndex42
					{
						switch buffer[position] {
						case '{':
							{
								position82 := position
								{
									position83 := position
									if buffer[position] != rune('{') {
										goto l40
									}
									position++
									{
										add(ruleAction18, position)
									}
									if !_rules[rulews]() {
										goto l40
									}
									{
										position85, tokenIndex85 := position, tokenIndex
										{
											position87 := position
											if !_rules[rulekeyval]() {
												goto l85
											}
										l88:
											{
												position89, tokenIndex89 := position, tokenIndex
												if !_rules[rulews]() {
													goto l89
												}
												{
													position90 := position
													{
														position91, tokenIndex91 := position, tokenIndex
														{
															position93, tokenIndex93 := position, tokenIndex
															if buffer[position] != rune(',') {
																goto l93
															}
															position++
															goto l92
														l93:
															position, tokenIndex = position93, tokenIndex93
														}
														{
															add(ruleAction21, position)
														}
														goto l91
													l92:
														position, tokenIndex = position91, tokenIndex91
														if buffer[position] != rune(',') {
															goto l89
														}
														position++
													}
												l91:
													add(ruleinlineTableCommaRequired, position90)
												}
												if !_rules[rulews]() {
													goto l89
												}
												if !_rules[rulekeyval]() {
													goto l89
												}
												goto l88
											l89:
												position, tokenIndex = position89, tokenIndex89
											}
											if !_rules[rulews]() {
												goto l85
											}
											{
												position95 := position
												{
													position96, tokenIndex96 := position, tokenIndex
													{
														position98, tokenIndex98 := position, tokenIndex
														if buffer[position] != rune(',') {
															goto l98
														}
														position++
														goto l97
													l98:
														position, tokenIndex = position98, tokenIndex98
													}
													goto l96
												l97:
													position, tokenIndex = position96, tokenIndex96
													if buffer[position] != rune(',') {
														goto l85
													}
													position++
													{
														add(ruleAction20, position)
													}
												}
											l96:
												add(ruleinlineTableCommaForbidden, position95)
											}
											add(ruleinlineTableKeyValues, position87)
										}
										goto l86
									l85:
										position, tokenIndex = position85, tokenIndex85
									}
								l86:
									if !_rules[rulews]() {
										goto l40
									}
									if buffer[position] != rune('}') {
										goto l40
									}
									position++
									{
										add(ruleAction19, position)
									}
									add(ruleinlineTable, position83)
								}
								add(rulePegText, position82)
							}
							{
								add(ruleAction8, position)
							}
						case '[':
							{
								position102 := position
								{
									position103 := position
									if buffer[position] != rune('[') {
										goto l40
									}
									position++
									{
										add(ruleAction30, position)
									}
									if !_rules[rulewsnl]() {
										goto l40
									}
									{
										position105, tokenIndex105 := position, tokenIndex
										{
											position107 := position
										l108:
											{
												position109, tokenIndex109 := position, tokenIndex
												if !_rules[rulewsnl]() {
													goto l109
												}
												if !_rules[rulecomment]() {
													goto l109
												}
												goto l108
											l109:
												position, tokenIndex = position109, tokenIndex109
											}
											if !_rules[rulewsnl]() {
												goto l105
											}
											if !_rules[ruleval]() {
												goto l105
											}
											{
												add(ruleAction31, position)
											}
										l111:
											{
												position112, tokenIndex112 := position, tokenIndex
											l113:
												{
													position114, tokenIndex114 := position, tokenIndex
													if !_rules[rulewsnl]() {
														goto l114
													}
													if !_rules[rulecomment]() {
														goto l114
													}
													goto l113
												l114:
													position, tokenIndex = position114, tokenIndex114
												}
												if !_rules[rulewsnl]() {
													goto l112
												}
												if !_rules[rulearraySep]() {
													goto l112
												}
											l115:
												{
													position116, tokenIndex116 := position, tokenIndex
													if !_rules[rulewsnl]() {
														goto l116
													}
													if !_rules[rulecomment]() {
														goto l116
													}
													goto l115
												l116:
													position, tokenIndex = position116, tokenIndex116
												}
												if !_rules[rulewsnl]() {
													goto l112
												}
												if !_rules[ruleval]() {
													goto l112
												}
												{
													add(ruleAction32, position)
												}
												goto l111
											l112:
												position, tokenIndex = position112, tokenIndex112
											}
										l118:
											{
												position119, tokenIndex119 := position, tokenIndex
												if !_rules[rulewsnl]() {
													goto l119
												}
												if !_rules[rulecomment]() {
													goto l119
												}
												goto l118
											l119:
												position, tokenIndex = position119, tokenIndex119
											}
											if !_rules[rulewsnl]() {
												goto l105
											}
											{
												position120, tokenIndex120 := position, tokenIndex
												if !_rules[rulearraySep]() {
													goto l120
												}
												goto l121
											l120:
												position, tokenIndex = position120, tokenIndex120
											}
										l121:
										l122:
											{
												position123, tokenIndex123 := position, tokenIndex
												if !_rules[rulewsnl]() {
													goto l123
												}
												if !_rules[rulecomment]() {
													goto l123
												}
												goto l122
											l123:
												position, tokenIndex = position123, tokenIndex123
											}
											add(rulearrayValues, position107)
										}
										goto l106
									l105:
										position, tokenIndex = position105, tokenIndex105
									}
								l106:
									if !_rules[rulewsnl]() {
										goto l40
									}
									if buffer[position] != rune(']') {
										goto l40
									}
									position++
									add(rulearray, position103)
								}
								add(rulePegText, position102)
							}
							{
								add(ruleAction7, position)
							}
						case 'f', 't':
							{
								position125 := position
								{
									position126 := position
									{
										position127, tokenIndex127 := position, tokenIndex
										if buffer[position] != rune('t') {
											goto l128
										}
										position++
										if buffer[position] != rune('r') {
											goto l128
										}
										position++
										if buffer[position] != rune('u') {
											goto l128
										}
										position++
										if buffer[position] != rune('e') {
											goto l128
										}
										position++
										goto l127
									l128:
										position, tokenIndex = position127, tokenIndex127
										if buffer[position] != rune('f') {
											goto l40
										}
										position++
										if buffer[position] != rune('a') {
											goto l40
										}
										position++
										if buffer[position] != rune('l') {
											goto l40
										}
										position++
										if buffer[position] != rune('s') {
											goto l40
										}
										position++
										if buffer[position] != rune('e') {
											goto l40
										}
										position++
									}
								l127:
									add(ruleboolean, position126)
								}
								add(rulePegText, position125)
							}
							{
								add(ruleAction6, position)
							}
						case '"', '\'':
							{
								position130 := position
								{
									position131 := position
									{
										position132, tokenIndex132 := position, tokenIndex
										{
											position134 := position
											if buffer[position] != rune('\'') {
												goto l133
											}
											position++
											if buffer[position] != rune('\'') {
												goto l133
											}
											position++
											if buffer[position] != rune('\'') {
												goto l133
											}
											position++
											{
												position135 := position
												{
													position136 := position
												l137:
													{
														position138, tokenIndex138 := position, tokenIndex
														{
															position139, tokenIndex139 := position, tokenIndex
															if buffer[position] != rune('\'') {
																goto l139
															}
															position++
															if buffer[position] != rune('\'') {
																goto l139
															}
															position++
															if buffer[position] != rune('\'') {
																goto l139
															}
															position++
															goto l138
														l139:
															position, tokenIndex = position139, tokenIndex139
														}
														{
															position140, tokenIndex140 := position, tokenIndex
															{
																position142 := position
																{
																	position143, tokenIndex143 := position, tokenIndex
																	if !_rules[rulebadControl]() {
																		goto l144
																	}
																	goto l143
																l144:
																	position, tokenIndex = position143, tokenIndex143
																	{
																		position145, tokenIndex145 := position, tokenIndex
																		if buffer[position] != rune('\t') {
																			goto l146
																		}
																		position++
																		goto l145
																	l146:
																		position, tokenIndex = position145, tokenIndex145
																		if c := buffer[position]; c < rune(' ') || c > rune('\U0010ffff') {
																			goto l141
																		}
																		position++
																	}
																l145:
																}
															l143:
																add(rulemlLiteralChar, position142)
															}
															goto l140
														l141:
															position, tokenIndex = position140, tokenIndex140
															if !_rules[rulenewline]() {
																goto l138
															}
														}
													l140:
														goto l137
													l138:
														position, tokenIndex = position138, tokenIndex138
													}
													{
														position147, tokenIndex147 := position, tokenIndex
														{
															position149 := position
															{
																position150, tokenIndex150 := position, tokenIndex
																if buffer[position] != rune('\'') {
																	goto l151
																}
																position++
																if buffer[position] != rune('\'') {
																	goto l151
																}
																position++
																{
																	position152, tokenIndex152 := position, tokenIndex
																	if buffer[position] != rune('\'') {
																		goto l151
																	}
																	position++
																	if buffer[position] != rune('\'') {
																		goto l151
																	}
																	position++
																	if buffer[position] != rune('\'') {
																		goto l151
																	}
																	position++
																	position, tokenIndex = position152, tokenIndex152
																}
																goto l150
															l151:
																position, tokenIndex = position150, tokenIndex150
																if buffer[position] != rune('\'') {
																	goto l147
																}
																position++
																{
																	position153, tokenIndex153 := position, tokenIndex
																	if buffer[position] != rune('\'') {
																		goto l147
																	}
																	position++
																	if buffer[position] != rune('\'') {
																		goto l147
																	}
																	position++
																	if buffer[position] != rune('\'') {
																		goto l147
																	}
																	position++
																	position, tokenIndex = position153, tokenIndex153
																}
															}
														l150:
															add(rulemlLiteralBodyEndQuotes, position149)
														}
														goto l148
													l147:
														position, tokenIndex = position147, tokenIndex147
													}
												l148:
													add(rulemlLiteralBody, position136)
												}
												add(rulePegText, position135)
											}
											{
												add(ruleAction29, position)
											}
											if buffer[position] != rune('\'') {
												goto l133
											}
											position++
											if buffer[position] != rune('\'') {
												goto l133
											}
											position++
											if buffer[position] != rune('\'') {
												goto l133
											}
											position++
											add(rulemlLiteralString, position134)
										}
										goto l132
									l133:
										position, tokenIndex = position132, tokenIndex132
										{
											position156 := position
											if buffer[position] != rune('\'') {
												goto l155
											}
											position++
											{
												position157 := position
											l158:
												{
													position159, tokenIndex159 := position, tokenIndex
													{
														position160 := position
														{
															position161, tokenIndex161 := position, tokenIndex
															if !_rules[rulebadControl]() {
																goto l162
															}
															goto l161
														l162:
															position, tokenIndex = position161, tokenIndex161
															{
																switch buffer[position] {
																case '\t':
																	if buffer[position] != rune('\t') {
																		goto l159
																	}
																	position++
																case ' ', '!', '"', '#', '$', '%', '&':
																	if c := buffer[position]; c < rune(' ') || c > rune('&') {
																		goto l159
																	}
																	position++
																default:
																	if c := buffer[position]; c < rune('(') || c > rune('\U0010ffff') {
																		goto l159
																	}
																	position++
																}
															}

														}
													l161:
														add(ruleliteralChar, position160)
													}
													goto l158
												l159:
													position, tokenIndex = position159, tokenIndex159
												}
												add(rulePegText, position157)
											}
											if buffer[position] != rune('\'') {
												goto l155
											}
											position++
											{
												add(ruleAction28, position)
											}
											add(ruleliteralString, position156)
										}
										goto l132
									l155:
										position, tokenIndex = position132, tokenIndex132
										{
											position166 := position
											if buffer[position] != rune('"') {
												goto l165
											}
											position++
											if buffer[position] != rune('"') {
												goto l165
											}
											position++
											if buffer[position] != rune('"') {
												goto l165
											}
											position++
											{
												position167 := position
											l168:
												{
													position169, tokenIndex169 := position, tokenIndex
													{
														position170 := position
														{
															position171, tokenIndex171 := position, tokenIndex
															{
																position173, tokenIndex173 := position, tokenIndex
																if buffer[position] != rune('"') {
																	goto l173
																}
																position++
																if buffer[position] != rune('"') {
																	goto l173
																}
																position++
																if buffer[position] != rune('"') {
																	goto l173
																}
																position++
																goto l172
															l173:
																position, tokenIndex = position173, tokenIndex173
															}
															if buffer[position] != rune('"') {
																goto l172
															}
															position++
															{
																add(ruleAction24, position)
															}
															goto l171
														l172:
															position, tokenIndex = position171, tokenIndex171
															{
																position176 := position
																{
																	position177, tokenIndex177 := position, tokenIndex
																	if !_rules[rulebasicChar]() {
																		goto l178
																	}
																	goto l177
																l178:
																	position, tokenIndex = position177, tokenIndex177
																	if !_rules[rulenewline]() {
																		goto l175
																	}
																}
															l177:
																add(rulePegText, position176)
															}
															{
																add(ruleAction25, position)
															}
															goto l171
														l175:
															position, tokenIndex = position171, tokenIndex171
															if !_rules[ruleescape]() {
																goto l169
															}
															if !_rules[rulenewline]() {
																goto l169
															}
															if !_rules[rulewsnl]() {
																goto l169
															}
														}
													l171:
														add(rulemlBasicBodyChar, position170)
													}
													goto l168
												l169:
													position, tokenIndex = position169, tokenIndex169
												}
												{
													position180, tokenIndex180 := position, tokenIndex
													{
														position182 := position
														{
															position183, tokenIndex183 := position, tokenIndex
															if buffer[position] != rune('"') {
																goto l184
															}
															position++
															if buffer[position] != rune('"') {
																goto l184
															}
															position++
															{
																position185, tokenIndex185 := position, tokenIndex
																if buffer[position] != rune('"') {
																	goto l184
																}
																position++
																if buffer[position] != rune('"') {
																	goto l184
																}
																position++
																if buffer[position] != rune('"') {
																	goto l184
																}
																position++
																position, tokenIndex = position185, tokenIndex185
															}
															{
																add(ruleAction26, position)
															}
															goto l183
														l184:
															position, tokenIndex = position183, tokenIndex183
															if buffer[position] != rune('"') {
																goto l180
															}
															position++
															{
																position187, tokenIndex187 := position, tokenIndex
																if buffer[position] != rune('"') {
																	goto l180
																}
																position++
																if buffer[position] != rune('"') {
																	goto l180
																}
																position++
																if buffer[position] != rune('"') {
																	goto l180
																}
																position++
																position, tokenIndex = position187, tokenIndex187
															}
															{
																add(ruleAction27, position)
															}
														}
													l183:
														add(rulemlBasicBodyEndQuotes, position182)
													}
													goto l181
												l180:
													position, tokenIndex = position180, tokenIndex180
												}
											l181:
												add(rulemlBasicBody, position167)
											}
											if buffer[position] != rune('"') {
												goto l165
											}
											position++
											if buffer[position] != rune('"') {
												goto l165
											}
											position++
											if buffer[position] != rune('"') {
												goto l165
											}
											position++
											{
												add(ruleAction23, position)
											}
											add(rulemlBasicString, position166)
										}
										goto l132
									l165:
										position, tokenIndex = position132, tokenIndex132
										{
											position190 := position
											{
												position191 := position
												if buffer[position] != rune('"') {
													goto l40
												}
												position++
											l192:
												{
													position193, tokenIndex193 := position, tokenIndex
													if !_rules[rulebasicChar]() {
														goto l193
													}
													goto l192
												l193:
													position, tokenIndex = position193, tokenIndex193
												}
												if buffer[position] != rune('"') {
													goto l40
												}
												position++
												add(rulePegText, position191)
											}
											{
												add(ruleAction22, position)
											}
											add(rulebasicString, position190)
										}
									}
								l132:
									add(rulestring, position131)
								}
								add(rulePegText, position130)
							}
							{
								add(ruleAction5, position)
							}
						default:
							{
								position196 := position
								{
									position197 := position
									{
										position198, tokenIndex198 := position, tokenIndex
										{
											position200 := position
											if buffer[position] != rune('0') {
												goto l199
											}
											position++
											if buffer[position] != rune('x') {
												goto l199
											}
											position++
											if !_rules[rulehexDigit]() {
												goto l199
											}
										l201:
											{
												position202, tokenIndex202 := position, tokenIndex
												{
													position203, tokenIndex203 := position, tokenIndex
													if !_rules[rulehexDigit]() {
														goto l204
													}
													goto l203
												l204:
													position, tokenIndex = position203, tokenIndex203
													if buffer[position] != rune('_') {
														goto l202
													}
													position++
													if !_rules[rulehexDigit]() {
														goto l202
													}
												}
											l203:
												goto l201
											l202:
												position, tokenIndex = position202, tokenIndex202
											}
											add(rulehexInt, position200)
										}
										goto l198
									l199:
										position, tokenIndex = position198, tokenIndex198
										{
											position206 := position
											if buffer[position] != rune('0') {
												goto l205
											}
											position++
											if buffer[position] != rune('o') {
												goto l205
											}
											position++
											if !_rules[ruleoctalDigit]() {
												goto l205
											}
										l207:
											{
												position208, tokenIndex208 := position, tokenIndex
												{
													position209, tokenIndex209 := position, tokenIndex
													if !_rules[ruleoctalDigit]() {
														goto l210
													}
													goto l209
												l210:
													position, tokenIndex = position209, tokenIndex209
													if buffer[position] != rune('_') {
														goto l208
													}
													position++
													if !_rules[ruleoctalDigit]() {
														goto l208
													}
												}
											l209:
												goto l207
											l208:
												position, tokenIndex = position208, tokenIndex208
											}
											add(ruleoctalInt, position206)
										}
										goto l198
									l205:
										position, tokenIndex = position198, tokenIndex198
										{
											position212 := position
											if buffer[position] != rune('0') {
												goto l211
											}
											position++
											if buffer[position] != rune('b') {
												goto l211
											}
											position++
											if !_rules[rulebinaryDigit]() {
												goto l211
											}
										l213:
											{
												position214, tokenIndex214 := position, tokenIndex
												{
													position215, tokenIndex215 := position, tokenIndex
													if !_rules[rulebinaryDigit]() {
														goto l216
													}
													goto l215
												l216:
													position, tokenIndex = position215, tokenIndex215
													if buffer[position] != rune('_') {
														goto l214
													}
													position++
													if !_rules[ruleoctalDigit]() {
														goto l214
													}
												}
											l215:
												goto l213
											l214:
												position, tokenIndex = position214, tokenIndex214
											}
											add(rulebinaryInt, position212)
										}
										goto l198
									l211:
										position, tokenIndex = position198, tokenIndex198
										if !_rules[ruledecimalInt]() {
											goto l217
										}
										goto l198
									l217:
										position, tokenIndex = position198, tokenIndex198
										{
											position218, tokenIndex218 := position, tokenIndex
											if buffer[position] != rune('+') {
												goto l219
											}
											position++
											goto l218
										l219:
											position, tokenIndex = position218, tokenIndex218
											if buffer[position] != rune('-') {
												goto l40
											}
											position++
										}
									l218:
										if !_rules[ruledecimalInt]() {
											goto l40
										}
									}
								l198:
									add(ruleinteger, position197)
								}
								add(rulePegText, position196)
							}
							{
								add(ruleAction4, position)
							}
						}
					}

				}
			l42:
				add(ruleval, position41)
			}
			return true
		l40:
			position, tokenIndex = position40, tokenIndex40
			return false
		},
		/* 3 ws <- <(' ' / '\t')*> */
		func() bool {
			{
				position222 := position
			l223:
				{
					position224, tokenIndex224 := position, tokenIndex
					{
						position225, tokenIndex225 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l226
						}
						position++
						goto l225
					l226:
						position, tokenIndex = position225, tokenIndex225
						if buffer[position] != rune('\t') {
							goto l224
						}
						position++
					}
				l225:
					goto l223
				l224:
					position, tokenIndex = position224, tokenIndex224
				}
				add(rulews, position222)
			}
			return true
		},
		/* 4 wsnl <- <((&('\t') '\t') | (&(' ') ' ') | (&('\n' | '\r') newline))*> */
		func() bool {
			{
				position228 := position
			l229:
				{
					position230, tokenIndex230 := position, tokenIndex
					{
						switch buffer[position] {
						case '\t':
							if buffer[position] != rune('\t') {
								goto l230
							}
							position++
						case ' ':
							if buffer[position] != rune(' ') {
								goto l230
							}
							position++
						default:
							if !_rules[rulenewline]() {
								goto l230
							}
						}
					}

					goto l229
				l230:
					position, tokenIndex = position230, tokenIndex230
				}
				add(rulewsnl, position228)
			}
			return true
		},
		/* 5 comment <- <('#' (badControl / ('\t' / [ -\U0010ffff]))*)> */
		func() bool {
			position232, tokenIndex232 := position, tokenIndex
			{
				position233 := position
				if buffer[position] != rune('#') {
					goto l232
				}
				position++
			l234:
				{
					position235, tokenIndex235 := position, tokenIndex
					{
						position236, tokenIndex236 := position, tokenIndex
						if !_rules[rulebadControl]() {
							goto l237
						}
						goto l236
					l237:
						position, tokenIndex = position236, tokenIndex236
						{
							position238, tokenIndex238 := position, tokenIndex
							if buffer[position] != rune('\t') {
								goto l239
							}
							position++
							goto l238
						l239:
							position, tokenIndex = position238, tokenIndex238
							if c := buffer[position]; c < rune(' ') || c > rune('\U0010ffff') {
								goto l235
							}
							position++
						}
					l238:
					}
				l236:
					goto l234
				l235:
					position, tokenIndex = position235, tokenIndex235
				}
				add(rulecomment, position233)
			}
			return true
		l232:
			position, tokenIndex = position232, tokenIndex232
			return false
		},
		/* 6 newline <- <((('\r' '\n') / '\n') Action9)> */
		func() bool {
			position240, tokenIndex240 := position, tokenIndex
			{
				position241 := position
				{
					position242, tokenIndex242 := position, tokenIndex
					if buffer[position] != rune('\r') {
						goto l243
					}
					position++
					if buffer[position] != rune('\n') {
						goto l243
					}
					position++
					goto l242
				l243:
					position, tokenIndex = position242, tokenIndex242
					if buffer[position] != rune('\n') {
						goto l240
					}
					position++
				}
			l242:
				{
					add(ruleAction9, position)
				}
				add(rulenewline, position241)
			}
			return true
		l240:
			position, tokenIndex = position240, tokenIndex240
			return false
		},
		/* 7 newlineRequired <- <((!newline Action10) / newline)> */
		nil,
		/* 8 badControl <- <(<((&('\f') '\f') | (&('\v') '\v') | (&('\u007f') '\u007f') | (&('\x00' | '\x01' | '\x02' | '\x03' | '\x04' | '\x05' | '\x06' | '\a' | '\b') [\x00-\b]) | (&('\x0e' | '\x0f' | '\x10' | '\x11' | '\x12' | '\x13' | '\x14' | '\x15' | '\x16' | '\x17' | '\x18' | '\x19' | '\x1a' | '\x1b' | '\x1c' | '\x1d' | '\x1e' | '\x1f') [\x0e-\x1f]))> Action11)> */
		func() bool {
			position246, tokenIndex246 := position, tokenIndex
			{
				position247 := position
				{
					position248 := position
					{
						switch buffer[position] {
						case '\f':
							if buffer[position] != rune('\f') {
								goto l246
							}
							position++
						case '\v':
							if buffer[position] != rune('\v') {
								goto l246
							}
							position++
						case '\u007f':
							if buffer[position] != rune('\u007f') {
								goto l246
							}
							position++
						case '\x00', '\x01', '\x02', '\x03', '\x04', '\x05', '\x06', '\a', '\b':
							if c := buffer[position]; c < rune('\x00') || c > rune('\b') {
								goto l246
							}
							position++
						default:
							if c := buffer[position]; c < rune('\x0e') || c > rune('\x1f') {
								goto l246
							}
							position++
						}
					}

					add(rulePegText, position248)
				}
				{
					add(ruleAction11, position)
				}
				add(rulebadControl, position247)
			}
			return true
		l246:
			position, tokenIndex = position246, tokenIndex246
			return false
		},
		/* 9 table <- <(stdTable / arrayTable)> */
		nil,
		/* 10 stdTable <- <('[' ws <tableKey> ws ']' Action12)> */
		nil,
		/* 11 arrayTable <- <('[' '[' ws <tableKey> ws (']' ']') Action13)> */
		nil,
		/* 12 keyval <- <(key ws '=' ws val Action14)> */
		func() bool {
			position254, tokenIndex254 := position, tokenIndex
			{
				position255 := position
				if !_rules[rulekey]() {
					goto l254
				}
				if !_rules[rulews]() {
					goto l254
				}
				if buffer[position] != rune('=') {
					goto l254
				}
				position++
				if !_rules[rulews]() {
					goto l254
				}
				if !_rules[ruleval]() {
					goto l254
				}
				{
					add(ruleAction14, position)
				}
				add(rulekeyval, position255)
			}
			return true
		l254:
			position, tokenIndex = position254, tokenIndex254
			return false
		},
		/* 13 key <- <(bareKey / quotedKey)> */
		func() bool {
			position257, tokenIndex257 := position, tokenIndex
			{
				position258 := position
				{
					position259, tokenIndex259 := position, tokenIndex
					{
						position261 := position
						{
							position262 := position
							{
								position265 := position
								{
									position266, tokenIndex266 := position, tokenIndex
									if !_rules[rulebadControl]() {
										goto l267
									}
									goto l266
								l267:
									position, tokenIndex = position266, tokenIndex266
									{
										switch buffer[position] {
										case '_':
											if buffer[position] != rune('_') {
												goto l260
											}
											position++
										case '-':
											if buffer[position] != rune('-') {
												goto l260
											}
											position++
										case 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z':
											if c := buffer[position]; c < rune('a') || c > rune('z') {
												goto l260
											}
											position++
										case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
											if c := buffer[position]; c < rune('0') || c > rune('9') {
												goto l260
											}
											position++
										default:
											if c := buffer[position]; c < rune('A') || c > rune('Z') {
												goto l260
											}
											position++
										}
									}

								}
							l266:
								add(rulebareKeyChar, position265)
							}
						l263:
							{
								position264, tokenIndex264 := position, tokenIndex
								{
									position269 := position
									{
										position270, tokenIndex270 := position, tokenIndex
										if !_rules[rulebadControl]() {
											goto l271
										}
										goto l270
									l271:
										position, tokenIndex = position270, tokenIndex270
										{
											switch buffer[position] {
											case '_':
												if buffer[position] != rune('_') {
													goto l264
												}
												position++
											case '-':
												if buffer[position] != rune('-') {
													goto l264
												}
												position++
											case 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z':
												if c := buffer[position]; c < rune('a') || c > rune('z') {
													goto l264
												}
												position++
											case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
												if c := buffer[position]; c < rune('0') || c > rune('9') {
													goto l264
												}
												position++
											default:
												if c := buffer[position]; c < rune('A') || c > rune('Z') {
													goto l264
												}
												position++
											}
										}

									}
								l270:
									add(rulebareKeyChar, position269)
								}
								goto l263
							l264:
								position, tokenIndex = position264, tokenIndex264
							}
							add(rulePegText, position262)
						}
						{
							add(ruleAction15, position)
						}
						add(rulebareKey, position261)
					}
					goto l259
				l260:
					position, tokenIndex = position259, tokenIndex259
					{
						position274 := position
						{
							position275 := position
							if buffer[position] != rune('"') {
								goto l257
							}
							position++
						l276:
							{
								position277, tokenIndex277 := position, tokenIndex
								if !_rules[rulebasicChar]() {
									goto l277
								}
								goto l276
							l277:
								position, tokenIndex = position277, tokenIndex277
							}
							if buffer[position] != rune('"') {
								goto l257
							}
							position++
							add(rulePegText, position275)
						}
						{
							add(ruleAction16, position)
						}
						add(rulequotedKey, position274)
					}
				}
			l259:
				add(rulekey, position258)
			}
			return true
		l257:
			position, tokenIndex = position257, tokenIndex257
			return false
		},
		/* 14 bareKey <- <(<bareKeyChar+> Action15)> */
		nil,
		/* 15 bareKeyChar <- <(badControl / ((&('_') '_') | (&('-') '-') | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z])))> */
		nil,
		/* 16 quotedKey <- <(<('"' basicChar* '"')> Action16)> */
		nil,
		/* 17 tableKey <- <(tableKeyComp (tableKeySep tableKeyComp)*)> */
		func() bool {
			position282, tokenIndex282 := position, tokenIndex
			{
				position283 := position
				if !_rules[ruletableKeyComp]() {
					goto l282
				}
			l284:
				{
					position285, tokenIndex285 := position, tokenIndex
					{
						position286 := position
						if !_rules[rulews]() {
							goto l285
						}
						if buffer[position] != rune('.') {
							goto l285
						}
						position++
						if !_rules[rulews]() {
							goto l285
						}
						add(ruletableKeySep, position286)
					}
					if !_rules[ruletableKeyComp]() {
						goto l285
					}
					goto l284
				l285:
					position, tokenIndex = position285, tokenIndex285
				}
				add(ruletableKey, position283)
			}
			return true
		l282:
			position, tokenIndex = position282, tokenIndex282
			return false
		},
		/* 18 tableKeyComp <- <(key Action17)> */
		func() bool {
			position287, tokenIndex287 := position, tokenIndex
			{
				position288 := position
				if !_rules[rulekey]() {
					goto l287
				}
				{
					add(ruleAction17, position)
				}
				add(ruletableKeyComp, position288)
			}
			return true
		l287:
			position, tokenIndex = position287, tokenIndex287
			return false
		},
		/* 19 tableKeySep <- <(ws '.' ws)> */
		nil,
		/* 20 inlineTable <- <('{' Action18 ws inlineTableKeyValues? ws '}' Action19)> */
		nil,
		/* 21 inlineTableKeyValues <- <(keyval (ws inlineTableCommaRequired ws keyval)* ws inlineTableCommaForbidden)> */
		nil,
		/* 22 inlineTableCommaForbidden <- <(!',' / (',' Action20))> */
		nil,
		/* 23 inlineTableCommaRequired <- <((!',' Action21) / ',')> */
		nil,
		/* 24 boolean <- <(('t' 'r' 'u' 'e') / ('f' 'a' 'l' 's' 'e'))> */
		nil,
		/* 25 integer <- <(hexInt / octalInt / binaryInt / decimalInt / (('+' / '-') decimalInt))> */
		nil,
		/* 26 decimalInt <- <(([1-9] (decimalDigit / ('_' decimalDigit))+) / decimalDigit)> */
		func() bool {
			position297, tokenIndex297 := position, tokenIndex
			{
				position298 := position
				{
					position299, tokenIndex299 := position, tokenIndex
					if c := buffer[position]; c < rune('1') || c > rune('9') {
						goto l300
					}
					position++
					{
						position303, tokenIndex303 := position, tokenIndex
						if !_rules[ruledecimalDigit]() {
							goto l304
						}
						goto l303
					l304:
						position, tokenIndex = position303, tokenIndex303
						if buffer[position] != rune('_') {
							goto l300
						}
						position++
						if !_rules[ruledecimalDigit]() {
							goto l300
						}
					}
				l303:
				l301:
					{
						position302, tokenIndex302 := position, tokenIndex
						{
							position305, tokenIndex305 := position, tokenIndex
							if !_rules[ruledecimalDigit]() {
								goto l306
							}
							goto l305
						l306:
							position, tokenIndex = position305, tokenIndex305
							if buffer[position] != rune('_') {
								goto l302
							}
							position++
							if !_rules[ruledecimalDigit]() {
								goto l302
							}
						}
					l305:
						goto l301
					l302:
						position, tokenIndex = position302, tokenIndex302
					}
					goto l299
				l300:
					position, tokenIndex = position299, tokenIndex299
					if !_rules[ruledecimalDigit]() {
						goto l297
					}
				}
			l299:
				add(ruledecimalInt, position298)
			}
			return true
		l297:
			position, tokenIndex = position297, tokenIndex297
			return false
		},
		/* 27 decimalDigit <- <[0-9]> */
		func() bool {
			position307, tokenIndex307 := position, tokenIndex
			{
				position308 := position
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l307
				}
				position++
				add(ruledecimalDigit, position308)
			}
			return true
		l307:
			position, tokenIndex = position307, tokenIndex307
			return false
		},
		/* 28 hexInt <- <('0' 'x' hexDigit (hexDigit / ('_' hexDigit))*)> */
		nil,
		/* 29 hexDigit <- <([0-9] / [0-9] / ([a-f] / [A-F]))> */
		func() bool {
			position310, tokenIndex310 := position, tokenIndex
			{
				position311 := position
				{
					position312, tokenIndex312 := position, tokenIndex
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l313
					}
					position++
					goto l312
				l313:
					position, tokenIndex = position312, tokenIndex312
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l314
					}
					position++
					goto l312
				l314:
					position, tokenIndex = position312, tokenIndex312
					{
						position315, tokenIndex315 := position, tokenIndex
						if c := buffer[position]; c < rune('a') || c > rune('f') {
							goto l316
						}
						position++
						goto l315
					l316:
						position, tokenIndex = position315, tokenIndex315
						if c := buffer[position]; c < rune('A') || c > rune('F') {
							goto l310
						}
						position++
					}
				l315:
				}
			l312:
				add(rulehexDigit, position311)
			}
			return true
		l310:
			position, tokenIndex = position310, tokenIndex310
			return false
		},
		/* 30 octalInt <- <('0' 'o' octalDigit (octalDigit / ('_' octalDigit))*)> */
		nil,
		/* 31 octalDigit <- <[0-7]> */
		func() bool {
			position318, tokenIndex318 := position, tokenIndex
			{
				position319 := position
				if c := buffer[position]; c < rune('0') || c > rune('7') {
					goto l318
				}
				position++
				add(ruleoctalDigit, position319)
			}
			return true
		l318:
			position, tokenIndex = position318, tokenIndex318
			return false
		},
		/* 32 binaryInt <- <('0' 'b' binaryDigit (binaryDigit / ('_' octalDigit))*)> */
		nil,
		/* 33 binaryDigit <- <('0' / '1')> */
		func() bool {
			position321, tokenIndex321 := position, tokenIndex
			{
				position322 := position
				{
					position323, tokenIndex323 := position, tokenIndex
					if buffer[position] != rune('0') {
						goto l324
					}
					position++
					goto l323
				l324:
					position, tokenIndex = position323, tokenIndex323
					if buffer[position] != rune('1') {
						goto l321
					}
					position++
				}
			l323:
				add(rulebinaryDigit, position322)
			}
			return true
		l321:
			position, tokenIndex = position321, tokenIndex321
			return false
		},
		/* 34 float <- <(('+' / '-')? ((&('i') ('i' 'n' 'f')) | (&('n') ('n' 'a' 'n')) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') floatDigits)))> */
		nil,
		/* 35 floatDigits <- <(decimalInt ((floatFrac floatExp?) / (floatFrac? floatExp)))> */
		nil,
		/* 36 floatFrac <- <('.' decimalDigit (decimalDigit / ('_' decimalDigit))*)> */
		func() bool {
			position327, tokenIndex327 := position, tokenIndex
			{
				position328 := position
				if buffer[position] != rune('.') {
					goto l327
				}
				position++
				if !_rules[ruledecimalDigit]() {
					goto l327
				}
			l329:
				{
					position330, tokenIndex330 := position, tokenIndex
					{
						position331, tokenIndex331 := position, tokenIndex
						if !_rules[ruledecimalDigit]() {
							goto l332
						}
						goto l331
					l332:
						position, tokenIndex = position331, tokenIndex331
						if buffer[position] != rune('_') {
							goto l330
						}
						position++
						if !_rules[ruledecimalDigit]() {
							goto l330
						}
					}
				l331:
					goto l329
				l330:
					position, tokenIndex = position330, tokenIndex330
				}
				add(rulefloatFrac, position328)
			}
			return true
		l327:
			position, tokenIndex = position327, tokenIndex327
			return false
		},
		/* 37 floatExp <- <(('e' / 'E') ('-' / '+')? decimalDigit (decimalDigit / ('_' decimalDigit))*)> */
		func() bool {
			position333, tokenIndex333 := position, tokenIndex
			{
				position334 := position
				{
					position335, tokenIndex335 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l336
					}
					position++
					goto l335
				l336:
					position, tokenIndex = position335, tokenIndex335
					if buffer[position] != rune('E') {
						goto l333
					}
					position++
				}
			l335:
				{
					position337, tokenIndex337 := position, tokenIndex
					{
						position339, tokenIndex339 := position, tokenIndex
						if buffer[position] != rune('-') {
							goto l340
						}
						position++
						goto l339
					l340:
						position, tokenIndex = position339, tokenIndex339
						if buffer[position] != rune('+') {
							goto l337
						}
						position++
					}
				l339:
					goto l338
				l337:
					position, tokenIndex = position337, tokenIndex337
				}
			l338:
				if !_rules[ruledecimalDigit]() {
					goto l333
				}
			l341:
				{
					position342, tokenIndex342 := position, tokenIndex
					{
						position343, tokenIndex343 := position, tokenIndex
						if !_rules[ruledecimalDigit]() {
							goto l344
						}
						goto l343
					l344:
						position, tokenIndex = position343, tokenIndex343
						if buffer[position] != rune('_') {
							goto l342
						}
						position++
						if !_rules[ruledecimalDigit]() {
							goto l342
						}
					}
				l343:
					goto l341
				l342:
					position, tokenIndex = position342, tokenIndex342
				}
				add(rulefloatExp, position334)
			}
			return true
		l333:
			position, tokenIndex = position333, tokenIndex333
			return false
		},
		/* 38 escaped <- <(escape ((&('U') ('U' hexQuad hexQuad)) | (&('u') ('u' hexQuad)) | (&('\\') '\\') | (&('/') '/') | (&('"') '"') | (&('r') 'r') | (&('f') 'f') | (&('n') 'n') | (&('t') 't') | (&('b') 'b')))> */
		nil,
		/* 39 escape <- <'\\'> */
		func() bool {
			position346, tokenIndex346 := position, tokenIndex
			{
				position347 := position
				if buffer[position] != rune('\\') {
					goto l346
				}
				position++
				add(ruleescape, position347)
			}
			return true
		l346:
			position, tokenIndex = position346, tokenIndex346
			return false
		},
		/* 40 hexQuad <- <(hexDigit hexDigit hexDigit hexDigit)> */
		func() bool {
			position348, tokenIndex348 := position, tokenIndex
			{
				position349 := position
				if !_rules[rulehexDigit]() {
					goto l348
				}
				if !_rules[rulehexDigit]() {
					goto l348
				}
				if !_rules[rulehexDigit]() {
					goto l348
				}
				if !_rules[rulehexDigit]() {
					goto l348
				}
				add(rulehexQuad, position349)
			}
			return true
		l348:
			position, tokenIndex = position348, tokenIndex348
			return false
		},
		/* 41 string <- <(mlLiteralString / literalString / mlBasicString / basicString)> */
		nil,
		/* 42 basicString <- <(<('"' basicChar* '"')> Action22)> */
		nil,
		/* 43 basicChar <- <(badControl / basicUnescaped / escaped)> */
		func() bool {
			position352, tokenIndex352 := position, tokenIndex
			{
				position353 := position
				{
					position354, tokenIndex354 := position, tokenIndex
					if !_rules[rulebadControl]() {
						goto l355
					}
					goto l354
				l355:
					position, tokenIndex = position354, tokenIndex354
					{
						position357 := position
						{
							switch buffer[position] {
							case '\t':
								if buffer[position] != rune('\t') {
									goto l356
								}
								position++
							case ' ', '!':
								if c := buffer[position]; c < rune(' ') || c > rune('!') {
									goto l356
								}
								position++
							case '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[':
								if c := buffer[position]; c < rune('#') || c > rune('[') {
									goto l356
								}
								position++
							default:
								if c := buffer[position]; c < rune(']') || c > rune('\U0010ffff') {
									goto l356
								}
								position++
							}
						}

						add(rulebasicUnescaped, position357)
					}
					goto l354
				l356:
					position, tokenIndex = position354, tokenIndex354
					{
						position359 := position
						if !_rules[ruleescape]() {
							goto l352
						}
						{
							switch buffer[position] {
							case 'U':
								if buffer[position] != rune('U') {
									goto l352
								}
								position++
								if !_rules[rulehexQuad]() {
									goto l352
								}
								if !_rules[rulehexQuad]() {
									goto l352
								}
							case 'u':
								if buffer[position] != rune('u') {
									goto l352
								}
								position++
								if !_rules[rulehexQuad]() {
									goto l352
								}
							case '\\':
								if buffer[position] != rune('\\') {
									goto l352
								}
								position++
							case '/':
								if buffer[position] != rune('/') {
									goto l352
								}
								position++
							case '"':
								if buffer[position] != rune('"') {
									goto l352
								}
								position++
							case 'r':
								if buffer[position] != rune('r') {
									goto l352
								}
								position++
							case 'f':
								if buffer[position] != rune('f') {
									goto l352
								}
								position++
							case 'n':
								if buffer[position] != rune('n') {
									goto l352
								}
								position++
							case 't':
								if buffer[position] != rune('t') {
									goto l352
								}
								position++
							default:
								if buffer[position] != rune('b') {
									goto l352
								}
								position++
							}
						}

						add(ruleescaped, position359)
					}
				}
			l354:
				add(rulebasicChar, position353)
			}
			return true
		l352:
			position, tokenIndex = position352, tokenIndex352
			return false
		},
		/* 44 basicUnescaped <- <((&('\t') '\t') | (&(' ' | '!') [ -!]) | (&('#' | '$' | '%' | '&' | '\'' | '(' | ')' | '*' | '+' | ',' | '-' | '.' | '/' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | ':' | ';' | '<' | '=' | '>' | '?' | '@' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | '[') [#-[]) | (&(']' | '^' | '_' | '`' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' | '{' | '|' | '}' | '~' | '\u007f' | '\u0080' | '\u0081' | '\u0082' | '\u0083' | '\u0084' | '\u0085' | '\u0086' | '\u0087' | '\u0088' | '\u0089' | '\u008a' | '\u008b' | '\u008c' | '\u008d' | '\u008e' | '\u008f' | '\u0090' | '\u0091' | '\u0092' | '\u0093' | '\u0094' | '\u0095' | '\u0096' | '\u0097' | '\u0098' | '\u0099' | '\u009a' | '\u009b' | '\u009c' | '\u009d' | '\u009e' | '\u009f' | '\u00a0' | '¡' | '¢' | '£' | '¤' | '¥' | '¦' | '§' | '¨' | '©' | 'ª' | '«' | '¬' | '\u00ad' | '®' | '¯' | '°' | '±' | '²' | '³' | '´' | 'µ' | '¶' | '·' | '¸' | '¹' | 'º' | '»' | '¼' | '½' | '¾' | '¿' | 'À' | 'Á' | 'Â' | 'Ã' | 'Ä' | 'Å' | 'Æ' | 'Ç' | 'È' | 'É' | 'Ê' | 'Ë' | 'Ì' | 'Í' | 'Î' | 'Ï' | 'Ð' | 'Ñ' | 'Ò' | 'Ó' | 'Ô' | 'Õ' | 'Ö' | '×' | 'Ø' | 'Ù' | 'Ú' | 'Û' | 'Ü' | 'Ý' | 'Þ' | 'ß' | 'à' | 'á' | 'â' | 'ã' | 'ä' | 'å' | 'æ' | 'ç' | 'è' | 'é' | 'ê' | 'ë' | 'ì' | 'í' | 'î' | 'ï' | 'ð' | 'ñ' | 'ò' | 'ó' | 'ô' | 'õ' | 'ö' | '÷' | 'ø' | 'ù' | 'ú' | 'û' | 'ü' | 'ý' | 'þ' | 'ÿ') []-\U0010ffff]))> */
		nil,
		/* 45 mlBasicString <- <('"' '"' '"' mlBasicBody ('"' '"' '"') Action23)> */
		nil,
		/* 46 mlBasicBody <- <(mlBasicBodyChar* mlBasicBodyEndQuotes?)> */
		nil,
		/* 47 mlBasicBodyChar <- <((!('"' '"' '"') '"' Action24) / (<(basicChar / newline)> Action25) / (escape newline wsnl))> */
		nil,
		/* 48 mlBasicBodyEndQuotes <- <(('"' '"' &('"' '"' '"') Action26) / ('"' &('"' '"' '"') Action27))> */
		nil,
		/* 49 literalString <- <('\'' <literalChar*> '\'' Action28)> */
		nil,
		/* 50 literalChar <- <(badControl / ((&('\t') '\t') | (&(' ' | '!' | '"' | '#' | '$' | '%' | '&') [ -&]) | (&('(' | ')' | '*' | '+' | ',' | '-' | '.' | '/' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | ':' | ';' | '<' | '=' | '>' | '?' | '@' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | '[' | '\\' | ']' | '^' | '_' | '`' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' | '{' | '|' | '}' | '~' | '\u007f' | '\u0080' | '\u0081' | '\u0082' | '\u0083' | '\u0084' | '\u0085' | '\u0086' | '\u0087' | '\u0088' | '\u0089' | '\u008a' | '\u008b' | '\u008c' | '\u008d' | '\u008e' | '\u008f' | '\u0090' | '\u0091' | '\u0092' | '\u0093' | '\u0094' | '\u0095' | '\u0096' | '\u0097' | '\u0098' | '\u0099' | '\u009a' | '\u009b' | '\u009c' | '\u009d' | '\u009e' | '\u009f' | '\u00a0' | '¡' | '¢' | '£' | '¤' | '¥' | '¦' | '§' | '¨' | '©' | 'ª' | '«' | '¬' | '\u00ad' | '®' | '¯' | '°' | '±' | '²' | '³' | '´' | 'µ' | '¶' | '·' | '¸' | '¹' | 'º' | '»' | '¼' | '½' | '¾' | '¿' | 'À' | 'Á' | 'Â' | 'Ã' | 'Ä' | 'Å' | 'Æ' | 'Ç' | 'È' | 'É' | 'Ê' | 'Ë' | 'Ì' | 'Í' | 'Î' | 'Ï' | 'Ð' | 'Ñ' | 'Ò' | 'Ó' | 'Ô' | 'Õ' | 'Ö' | '×' | 'Ø' | 'Ù' | 'Ú' | 'Û' | 'Ü' | 'Ý' | 'Þ' | 'ß' | 'à' | 'á' | 'â' | 'ã' | 'ä' | 'å' | 'æ' | 'ç' | 'è' | 'é' | 'ê' | 'ë' | 'ì' | 'í' | 'î' | 'ï' | 'ð' | 'ñ' | 'ò' | 'ó' | 'ô' | 'õ' | 'ö' | '÷' | 'ø' | 'ù' | 'ú' | 'û' | 'ü' | 'ý' | 'þ' | 'ÿ') [(-\U0010ffff])))> */
		nil,
		/* 51 mlLiteralString <- <('\'' '\'' '\'' <mlLiteralBody> Action29 ('\'' '\'' '\''))> */
		nil,
		/* 52 mlLiteralBody <- <((!('\'' '\'' '\'') (mlLiteralChar / newline))* mlLiteralBodyEndQuotes?)> */
		nil,
		/* 53 mlLiteralChar <- <(badControl / ('\t' / [ -\U0010ffff]))> */
		nil,
		/* 54 mlLiteralBodyEndQuotes <- <(('\'' '\'' &('\'' '\'' '\'')) / ('\'' &('\'' '\'' '\'')))> */
		nil,
		/* 55 datetime <- <((fullDate (((&(' ') ' ') | (&('T') 'T') | (&('t') 't')) fullTime)?) / partialTime)> */
		nil,
		/* 56 partialTime <- <(timeHour ':' timeMinute ':' timeSecond timeSecfrac?)> */
		func() bool {
			position373, tokenIndex373 := position, tokenIndex
			{
				position374 := position
				if !_rules[ruletimeHour]() {
					goto l373
				}
				if buffer[position] != rune(':') {
					goto l373
				}
				position++
				if !_rules[ruletimeMinute]() {
					goto l373
				}
				if buffer[position] != rune(':') {
					goto l373
				}
				position++
				{
					position375 := position
					if !_rules[ruledigitDual]() {
						goto l373
					}
					add(ruletimeSecond, position375)
				}
				{
					position376, tokenIndex376 := position, tokenIndex
					{
						position378 := position
						if buffer[position] != rune('.') {
							goto l376
						}
						position++
						if !_rules[ruledecimalDigit]() {
							goto l376
						}
					l379:
						{
							position380, tokenIndex380 := position, tokenIndex
							if !_rules[ruledecimalDigit]() {
								goto l380
							}
							goto l379
						l380:
							position, tokenIndex = position380, tokenIndex380
						}
						add(ruletimeSecfrac, position378)
					}
					goto l377
				l376:
					position, tokenIndex = position376, tokenIndex376
				}
			l377:
				add(rulepartialTime, position374)
			}
			return true
		l373:
			position, tokenIndex = position373, tokenIndex373
			return false
		},
		/* 57 fullDate <- <(dateFullYear '-' dateMonth '-' dateMDay)> */
		nil,
		/* 58 fullTime <- <(partialTime timeOffset?)> */
		nil,
		/* 59 dateFullYear <- <digitQuad> */
		nil,
		/* 60 dateMonth <- <digitDual> */
		nil,
		/* 61 dateMDay <- <digitDual> */
		nil,
		/* 62 timeHour <- <digitDual> */
		func() bool {
			position386, tokenIndex386 := position, tokenIndex
			{
				position387 := position
				if !_rules[ruledigitDual]() {
					goto l386
				}
				add(ruletimeHour, position387)
			}
			return true
		l386:
			position, tokenIndex = position386, tokenIndex386
			return false
		},
		/* 63 timeMinute <- <digitDual> */
		func() bool {
			position388, tokenIndex388 := position, tokenIndex
			{
				position389 := position
				if !_rules[ruledigitDual]() {
					goto l388
				}
				add(ruletimeMinute, position389)
			}
			return true
		l388:
			position, tokenIndex = position388, tokenIndex388
			return false
		},
		/* 64 timeSecond <- <digitDual> */
		nil,
		/* 65 timeSecfrac <- <('.' decimalDigit+)> */
		nil,
		/* 66 timeNumoffset <- <(('-' / '+') timeHour ':' timeMinute)> */
		nil,
		/* 67 timeOffset <- <((&('Z') 'Z') | (&('z') 'z') | (&('+' | '-') timeNumoffset))> */
		nil,
		/* 68 digitDual <- <(decimalDigit decimalDigit)> */
		func() bool {
			position394, tokenIndex394 := position, tokenIndex
			{
				position395 := position
				if !_rules[ruledecimalDigit]() {
					goto l394
				}
				if !_rules[ruledecimalDigit]() {
					goto l394
				}
				add(ruledigitDual, position395)
			}
			return true
		l394:
			position, tokenIndex = position394, tokenIndex394
			return false
		},
		/* 69 digitQuad <- <(digitDual digitDual)> */
		nil,
		/* 70 array <- <('[' Action30 wsnl arrayValues? wsnl ']')> */
		nil,
		/* 71 arrayValues <- <((wsnl comment)* wsnl val Action31 ((wsnl comment)* wsnl arraySep (wsnl comment)* wsnl val Action32)* (wsnl comment)* wsnl arraySep? (wsnl comment)*)> */
		nil,
		/* 72 arraySep <- <','> */
		func() bool {
			position399, tokenIndex399 := position, tokenIndex
			{
				position400 := position
				if buffer[position] != rune(',') {
					goto l399
				}
				position++
				add(rulearraySep, position400)
			}
			return true
		l399:
			position, tokenIndex = position399, tokenIndex399
			return false
		},
		/* 74 Action0 <- <{ _ = buffer }> */
		nil,
		nil,
		/* 76 Action1 <- <{ p.SetTableSource(begin, end) }> */
		nil,
		/* 77 Action2 <- <{ p.SetTime(begin, end) }> */
		nil,
		/* 78 Action3 <- <{ p.SetFloat(begin, end) }> */
		nil,
		/* 79 Action4 <- <{ p.SetInteger(begin, end) }> */
		nil,
		/* 80 Action5 <- <{ p.SetString(begin, end) }> */
		nil,
		/* 81 Action6 <- <{ p.SetBool(begin, end) }> */
		nil,
		/* 82 Action7 <- <{ p.SetArray(begin, end) }> */
		nil,
		/* 83 Action8 <- <{ p.SetInlineTableSource(begin, end) }> */
		nil,
		/* 84 Action9 <- <{ p.Newline() }> */
		nil,
		/* 85 Action10 <- <{ p.Error(errNewlineRequired) }> */
		nil,
		/* 86 Action11 <- <{
		    p.Error(&rawControlError{p.buffer[begin]})
		}> */
		nil,
		/* 87 Action12 <- <{ p.SetTable(p.buffer, begin, end) }> */
		nil,
		/* 88 Action13 <- <{ p.SetArrayTable(p.buffer, begin, end) }> */
		nil,
		/* 89 Action14 <- <{ p.AddKeyValue() }> */
		nil,
		/* 90 Action15 <- <{ p.SetKey(p.buffer, begin, end) }> */
		nil,
		/* 91 Action16 <- <{ p.SetKey(p.buffer, begin, end) }> */
		nil,
		/* 92 Action17 <- <{ p.AddTableKey() }> */
		nil,
		/* 93 Action18 <- <{ p.StartInlineTable() }> */
		nil,
		/* 94 Action19 <- <{ p.EndInlineTable() }> */
		nil,
		/* 95 Action20 <- <{ p.Error(errInlineTableCommaAtEnd) }> */
		nil,
		/* 96 Action21 <- <{ p.Error(errInlineTableCommaRequired) }> */
		nil,
		/* 97 Action22 <- <{ p.SetBasicString(p.buffer, begin, end) }> */
		nil,
		/* 98 Action23 <- <{ p.SetMultilineBasicString() }> */
		nil,
		/* 99 Action24 <- <{ p.AddMultilineBasicQuote() }> */
		nil,
		/* 100 Action25 <- <{ p.AddMultilineBasicBody(p.buffer, begin, end) }> */
		nil,
		/* 101 Action26 <- <{ p.AddMultilineBasicQuote(); p.AddMultilineBasicQuote() }> */
		nil,
		/* 102 Action27 <- <{ p.AddMultilineBasicQuote() }> */
		nil,
		/* 103 Action28 <- <{ p.SetLiteralString(p.buffer, begin, end) }> */
		nil,
		/* 104 Action29 <- <{ p.SetMultilineLiteralString(p.buffer, begin, end) }> */
		nil,
		/* 105 Action30 <- <{ p.StartArray() }> */
		nil,
		/* 106 Action31 <- <{ p.AddArrayVal() }> */
		nil,
		/* 107 Action32 <- <{ p.AddArrayVal() }> */
		nil,
	}
	p.rules = _rules
	return nil
}
