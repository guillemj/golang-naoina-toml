package toml

// Code generated by peg -switch -inline parse.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleTOML
	ruleExpression
	rulenewline
	rulews
	rulewsnl
	rulecomment
	ruleval
	ruletable
	rulestdTable
	rulearrayTable
	ruleinlineTable
	ruleinlineTableKeyValues
	rulekeyval
	rulekey
	rulebareKey
	rulequotedKey
	ruletableKey
	ruletableKeyComp
	ruletableKeySep
	ruleinlineTableValSep
	ruleboolean
	ruleinteger
	ruledecimalInt
	ruledecimalDigit
	rulehexInt
	rulehexDigit
	ruleoctalInt
	ruleoctalDigit
	rulebinaryInt
	rulebinaryDigit
	rulefloat
	rulefloatDigits
	rulefloatFrac
	rulefloatExp
	ruleescaped
	ruleescape
	rulehexQuad
	rulestring
	rulebasicString
	rulebasicChar
	rulebasicUnescaped
	rulemlBasicString
	rulemlBasicBody
	ruleliteralString
	ruleliteralChar
	rulemlLiteralString
	rulemlLiteralBody
	rulemlLiteralChar
	ruledateFullYear
	ruledateMonth
	ruledateMDay
	ruletimeHour
	ruletimeMinute
	ruletimeSecond
	ruletimeSecfrac
	ruletimeNumoffset
	ruletimeOffset
	rulepartialTime
	rulefullDate
	rulefullTime
	ruledatetime
	ruledigitDual
	ruledigitQuad
	rulearray
	rulearrayValues
	rulearraySep
	ruleAction0
	rulePegText
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
)

var rul3s = [...]string{
	"Unknown",
	"TOML",
	"Expression",
	"newline",
	"ws",
	"wsnl",
	"comment",
	"val",
	"table",
	"stdTable",
	"arrayTable",
	"inlineTable",
	"inlineTableKeyValues",
	"keyval",
	"key",
	"bareKey",
	"quotedKey",
	"tableKey",
	"tableKeyComp",
	"tableKeySep",
	"inlineTableValSep",
	"boolean",
	"integer",
	"decimalInt",
	"decimalDigit",
	"hexInt",
	"hexDigit",
	"octalInt",
	"octalDigit",
	"binaryInt",
	"binaryDigit",
	"float",
	"floatDigits",
	"floatFrac",
	"floatExp",
	"escaped",
	"escape",
	"hexQuad",
	"string",
	"basicString",
	"basicChar",
	"basicUnescaped",
	"mlBasicString",
	"mlBasicBody",
	"literalString",
	"literalChar",
	"mlLiteralString",
	"mlLiteralBody",
	"mlLiteralChar",
	"dateFullYear",
	"dateMonth",
	"dateMDay",
	"timeHour",
	"timeMinute",
	"timeSecond",
	"timeSecfrac",
	"timeNumoffset",
	"timeOffset",
	"partialTime",
	"fullDate",
	"fullTime",
	"datetime",
	"digitDual",
	"digitQuad",
	"array",
	"arrayValues",
	"arraySep",
	"Action0",
	"PegText",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type tomlParser struct {
	toml

	Buffer string
	buffer []rune
	rules  [95]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *tomlParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *tomlParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *tomlParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *tomlParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *tomlParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *tomlParser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func (p *tomlParser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:
			_ = buffer
		case ruleAction1:
			p.SetTableSource(begin, end)
		case ruleAction2:
			p.Newline()
		case ruleAction3:
			p.SetTime(begin, end)
		case ruleAction4:
			p.SetFloat(begin, end)
		case ruleAction5:
			p.SetInteger(begin, end)
		case ruleAction6:
			p.SetString(begin, end)
		case ruleAction7:
			p.SetBool(begin, end)
		case ruleAction8:
			p.SetArray(begin, end)
		case ruleAction9:
			p.SetInlineTableSource(begin, end)
		case ruleAction10:
			p.SetTable(p.buffer, begin, end)
		case ruleAction11:
			p.SetArrayTable(p.buffer, begin, end)
		case ruleAction12:
			p.StartInlineTable()
		case ruleAction13:
			p.EndInlineTable()
		case ruleAction14:
			p.AddKeyValue()
		case ruleAction15:
			p.SetKey(p.buffer, begin, end)
		case ruleAction16:
			p.SetKey(p.buffer, begin, end)
		case ruleAction17:
			p.AddTableKey()
		case ruleAction18:
			p.SetBasicString(p.buffer, begin, end)
		case ruleAction19:
			p.SetMultilineBasicString()
		case ruleAction20:
			p.AddMultilineBasicQuote()
		case ruleAction21:
			p.AddMultilineBasicBody(p.buffer, begin, end)
		case ruleAction22:
			p.SetLiteralString(p.buffer, begin, end)
		case ruleAction23:
			p.SetMultilineLiteralString(p.buffer, begin, end)
		case ruleAction24:
			p.StartArray()
		case ruleAction25:
			p.AddArrayVal()
		case ruleAction26:
			p.AddArrayVal()

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*tomlParser) error {
	return func(p *tomlParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*tomlParser) error {
	return func(p *tomlParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *tomlParser) Init(options ...func(*tomlParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 TOML <- <(Expression (newline Expression)* newline* !. Action0)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[ruleExpression]() {
					goto l0
				}
			l2:
				{
					position3, tokenIndex3 := position, tokenIndex
					if !_rules[rulenewline]() {
						goto l3
					}
					if !_rules[ruleExpression]() {
						goto l3
					}
					goto l2
				l3:
					position, tokenIndex = position3, tokenIndex3
				}
			l4:
				{
					position5, tokenIndex5 := position, tokenIndex
					if !_rules[rulenewline]() {
						goto l5
					}
					goto l4
				l5:
					position, tokenIndex = position5, tokenIndex5
				}
				{
					position6, tokenIndex6 := position, tokenIndex
					if !matchDot() {
						goto l6
					}
					goto l0
				l6:
					position, tokenIndex = position6, tokenIndex6
				}
				{
					add(ruleAction0, position)
				}
				add(ruleTOML, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 Expression <- <((<(ws table ws comment? (wsnl keyval ws comment?)*)> Action1) / (ws keyval ws comment?) / (ws comment?) / ws)> */
		func() bool {
			position8, tokenIndex8 := position, tokenIndex
			{
				position9 := position
				{
					position10, tokenIndex10 := position, tokenIndex
					{
						position12 := position
						if !_rules[rulews]() {
							goto l11
						}
						{
							position13 := position
							{
								position14, tokenIndex14 := position, tokenIndex
								{
									position16 := position
									if buffer[position] != rune('[') {
										goto l15
									}
									position++
									if !_rules[rulews]() {
										goto l15
									}
									{
										position17 := position
										if !_rules[ruletableKey]() {
											goto l15
										}
										add(rulePegText, position17)
									}
									if !_rules[rulews]() {
										goto l15
									}
									if buffer[position] != rune(']') {
										goto l15
									}
									position++
									{
										add(ruleAction10, position)
									}
									add(rulestdTable, position16)
								}
								goto l14
							l15:
								position, tokenIndex = position14, tokenIndex14
								{
									position19 := position
									if buffer[position] != rune('[') {
										goto l11
									}
									position++
									if buffer[position] != rune('[') {
										goto l11
									}
									position++
									if !_rules[rulews]() {
										goto l11
									}
									{
										position20 := position
										if !_rules[ruletableKey]() {
											goto l11
										}
										add(rulePegText, position20)
									}
									if !_rules[rulews]() {
										goto l11
									}
									if buffer[position] != rune(']') {
										goto l11
									}
									position++
									if buffer[position] != rune(']') {
										goto l11
									}
									position++
									{
										add(ruleAction11, position)
									}
									add(rulearrayTable, position19)
								}
							}
						l14:
							add(ruletable, position13)
						}
						if !_rules[rulews]() {
							goto l11
						}
						{
							position22, tokenIndex22 := position, tokenIndex
							if !_rules[rulecomment]() {
								goto l22
							}
							goto l23
						l22:
							position, tokenIndex = position22, tokenIndex22
						}
					l23:
					l24:
						{
							position25, tokenIndex25 := position, tokenIndex
							if !_rules[rulewsnl]() {
								goto l25
							}
							if !_rules[rulekeyval]() {
								goto l25
							}
							if !_rules[rulews]() {
								goto l25
							}
							{
								position26, tokenIndex26 := position, tokenIndex
								if !_rules[rulecomment]() {
									goto l26
								}
								goto l27
							l26:
								position, tokenIndex = position26, tokenIndex26
							}
						l27:
							goto l24
						l25:
							position, tokenIndex = position25, tokenIndex25
						}
						add(rulePegText, position12)
					}
					{
						add(ruleAction1, position)
					}
					goto l10
				l11:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[rulews]() {
						goto l29
					}
					if !_rules[rulekeyval]() {
						goto l29
					}
					if !_rules[rulews]() {
						goto l29
					}
					{
						position30, tokenIndex30 := position, tokenIndex
						if !_rules[rulecomment]() {
							goto l30
						}
						goto l31
					l30:
						position, tokenIndex = position30, tokenIndex30
					}
				l31:
					goto l10
				l29:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[rulews]() {
						goto l32
					}
					{
						position33, tokenIndex33 := position, tokenIndex
						if !_rules[rulecomment]() {
							goto l33
						}
						goto l34
					l33:
						position, tokenIndex = position33, tokenIndex33
					}
				l34:
					goto l10
				l32:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[rulews]() {
						goto l8
					}
				}
			l10:
				add(ruleExpression, position9)
			}
			return true
		l8:
			position, tokenIndex = position8, tokenIndex8
			return false
		},
		/* 2 newline <- <((('\r' '\n') / '\n') Action2)> */
		func() bool {
			position35, tokenIndex35 := position, tokenIndex
			{
				position36 := position
				{
					position37, tokenIndex37 := position, tokenIndex
					if buffer[position] != rune('\r') {
						goto l38
					}
					position++
					if buffer[position] != rune('\n') {
						goto l38
					}
					position++
					goto l37
				l38:
					position, tokenIndex = position37, tokenIndex37
					if buffer[position] != rune('\n') {
						goto l35
					}
					position++
				}
			l37:
				{
					add(ruleAction2, position)
				}
				add(rulenewline, position36)
			}
			return true
		l35:
			position, tokenIndex = position35, tokenIndex35
			return false
		},
		/* 3 ws <- <(' ' / '\t')*> */
		func() bool {
			{
				position41 := position
			l42:
				{
					position43, tokenIndex43 := position, tokenIndex
					{
						position44, tokenIndex44 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l45
						}
						position++
						goto l44
					l45:
						position, tokenIndex = position44, tokenIndex44
						if buffer[position] != rune('\t') {
							goto l43
						}
						position++
					}
				l44:
					goto l42
				l43:
					position, tokenIndex = position43, tokenIndex43
				}
				add(rulews, position41)
			}
			return true
		},
		/* 4 wsnl <- <((&('\t') '\t') | (&(' ') ' ') | (&('\n' | '\r') newline))*> */
		func() bool {
			{
				position47 := position
			l48:
				{
					position49, tokenIndex49 := position, tokenIndex
					{
						switch buffer[position] {
						case '\t':
							if buffer[position] != rune('\t') {
								goto l49
							}
							position++
						case ' ':
							if buffer[position] != rune(' ') {
								goto l49
							}
							position++
						default:
							if !_rules[rulenewline]() {
								goto l49
							}
						}
					}

					goto l48
				l49:
					position, tokenIndex = position49, tokenIndex49
				}
				add(rulewsnl, position47)
			}
			return true
		},
		/* 5 comment <- <('#' ('\t' / [ -\U0010ffff])*)> */
		func() bool {
			position51, tokenIndex51 := position, tokenIndex
			{
				position52 := position
				if buffer[position] != rune('#') {
					goto l51
				}
				position++
			l53:
				{
					position54, tokenIndex54 := position, tokenIndex
					{
						position55, tokenIndex55 := position, tokenIndex
						if buffer[position] != rune('\t') {
							goto l56
						}
						position++
						goto l55
					l56:
						position, tokenIndex = position55, tokenIndex55
						if c := buffer[position]; c < rune(' ') || c > rune('\U0010ffff') {
							goto l54
						}
						position++
					}
				l55:
					goto l53
				l54:
					position, tokenIndex = position54, tokenIndex54
				}
				add(rulecomment, position52)
			}
			return true
		l51:
			position, tokenIndex = position51, tokenIndex51
			return false
		},
		/* 6 val <- <((<datetime> Action3) / (<float> Action4) / ((&('{') (<inlineTable> Action9)) | (&('[') (<array> Action8)) | (&('f' | 't') (<boolean> Action7)) | (&('"' | '\'') (<string> Action6)) | (&('+' | '-' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') (<integer> Action5))))> */
		func() bool {
			position57, tokenIndex57 := position, tokenIndex
			{
				position58 := position
				{
					position59, tokenIndex59 := position, tokenIndex
					{
						position61 := position
						{
							position62 := position
							{
								position63, tokenIndex63 := position, tokenIndex
								{
									position65 := position
									{
										position66 := position
										{
											position67 := position
											if !_rules[ruledigitDual]() {
												goto l64
											}
											if !_rules[ruledigitDual]() {
												goto l64
											}
											add(ruledigitQuad, position67)
										}
										add(ruledateFullYear, position66)
									}
									if buffer[position] != rune('-') {
										goto l64
									}
									position++
									{
										position68 := position
										if !_rules[ruledigitDual]() {
											goto l64
										}
										add(ruledateMonth, position68)
									}
									if buffer[position] != rune('-') {
										goto l64
									}
									position++
									{
										position69 := position
										if !_rules[ruledigitDual]() {
											goto l64
										}
										add(ruledateMDay, position69)
									}
									add(rulefullDate, position65)
								}
								{
									position70, tokenIndex70 := position, tokenIndex
									{
										switch buffer[position] {
										case ' ':
											if buffer[position] != rune(' ') {
												goto l70
											}
											position++
										case 't':
											if buffer[position] != rune('t') {
												goto l70
											}
											position++
										default:
											if buffer[position] != rune('T') {
												goto l70
											}
											position++
										}
									}

									{
										position73 := position
										if !_rules[rulepartialTime]() {
											goto l70
										}
										{
											position74, tokenIndex74 := position, tokenIndex
											{
												position76 := position
												{
													switch buffer[position] {
													case 'z':
														if buffer[position] != rune('z') {
															goto l74
														}
														position++
													case 'Z':
														if buffer[position] != rune('Z') {
															goto l74
														}
														position++
													default:
														{
															position78 := position
															{
																position79, tokenIndex79 := position, tokenIndex
																if buffer[position] != rune('-') {
																	goto l80
																}
																position++
																goto l79
															l80:
																position, tokenIndex = position79, tokenIndex79
																if buffer[position] != rune('+') {
																	goto l74
																}
																position++
															}
														l79:
															if !_rules[ruletimeHour]() {
																goto l74
															}
															if buffer[position] != rune(':') {
																goto l74
															}
															position++
															if !_rules[ruletimeMinute]() {
																goto l74
															}
															add(ruletimeNumoffset, position78)
														}
													}
												}

												add(ruletimeOffset, position76)
											}
											goto l75
										l74:
											position, tokenIndex = position74, tokenIndex74
										}
									l75:
										add(rulefullTime, position73)
									}
									goto l71
								l70:
									position, tokenIndex = position70, tokenIndex70
								}
							l71:
								goto l63
							l64:
								position, tokenIndex = position63, tokenIndex63
								if !_rules[rulepartialTime]() {
									goto l60
								}
							}
						l63:
							add(ruledatetime, position62)
						}
						add(rulePegText, position61)
					}
					{
						add(ruleAction3, position)
					}
					goto l59
				l60:
					position, tokenIndex = position59, tokenIndex59
					{
						position83 := position
						{
							position84 := position
							{
								position85, tokenIndex85 := position, tokenIndex
								{
									position87, tokenIndex87 := position, tokenIndex
									if buffer[position] != rune('+') {
										goto l88
									}
									position++
									goto l87
								l88:
									position, tokenIndex = position87, tokenIndex87
									if buffer[position] != rune('-') {
										goto l85
									}
									position++
								}
							l87:
								goto l86
							l85:
								position, tokenIndex = position85, tokenIndex85
							}
						l86:
							{
								switch buffer[position] {
								case 'i':
									if buffer[position] != rune('i') {
										goto l82
									}
									position++
									if buffer[position] != rune('n') {
										goto l82
									}
									position++
									if buffer[position] != rune('f') {
										goto l82
									}
									position++
								case 'n':
									if buffer[position] != rune('n') {
										goto l82
									}
									position++
									if buffer[position] != rune('a') {
										goto l82
									}
									position++
									if buffer[position] != rune('n') {
										goto l82
									}
									position++
								default:
									{
										position90 := position
										if !_rules[ruledecimalInt]() {
											goto l82
										}
										{
											position91, tokenIndex91 := position, tokenIndex
											if !_rules[rulefloatFrac]() {
												goto l92
											}
											{
												position93, tokenIndex93 := position, tokenIndex
												if !_rules[rulefloatExp]() {
													goto l93
												}
												goto l94
											l93:
												position, tokenIndex = position93, tokenIndex93
											}
										l94:
											goto l91
										l92:
											position, tokenIndex = position91, tokenIndex91
											{
												position95, tokenIndex95 := position, tokenIndex
												if !_rules[rulefloatFrac]() {
													goto l95
												}
												goto l96
											l95:
												position, tokenIndex = position95, tokenIndex95
											}
										l96:
											if !_rules[rulefloatExp]() {
												goto l82
											}
										}
									l91:
										add(rulefloatDigits, position90)
									}
								}
							}

							add(rulefloat, position84)
						}
						add(rulePegText, position83)
					}
					{
						add(ruleAction4, position)
					}
					goto l59
				l82:
					position, tokenIndex = position59, tokenIndex59
					{
						switch buffer[position] {
						case '{':
							{
								position99 := position
								{
									position100 := position
									if buffer[position] != rune('{') {
										goto l57
									}
									position++
									{
										add(ruleAction12, position)
									}
									if !_rules[rulews]() {
										goto l57
									}
									{
										position102 := position
									l103:
										{
											position104, tokenIndex104 := position, tokenIndex
											if !_rules[rulekeyval]() {
												goto l104
											}
											{
												position105, tokenIndex105 := position, tokenIndex
												{
													position107 := position
													if !_rules[rulews]() {
														goto l105
													}
													if buffer[position] != rune(',') {
														goto l105
													}
													position++
													if !_rules[rulews]() {
														goto l105
													}
													add(ruleinlineTableValSep, position107)
												}
												goto l106
											l105:
												position, tokenIndex = position105, tokenIndex105
											}
										l106:
											goto l103
										l104:
											position, tokenIndex = position104, tokenIndex104
										}
										add(ruleinlineTableKeyValues, position102)
									}
									if !_rules[rulews]() {
										goto l57
									}
									if buffer[position] != rune('}') {
										goto l57
									}
									position++
									{
										add(ruleAction13, position)
									}
									add(ruleinlineTable, position100)
								}
								add(rulePegText, position99)
							}
							{
								add(ruleAction9, position)
							}
						case '[':
							{
								position110 := position
								{
									position111 := position
									if buffer[position] != rune('[') {
										goto l57
									}
									position++
									{
										add(ruleAction24, position)
									}
									if !_rules[rulewsnl]() {
										goto l57
									}
									{
										position113, tokenIndex113 := position, tokenIndex
										{
											position115 := position
										l116:
											{
												position117, tokenIndex117 := position, tokenIndex
												if !_rules[rulewsnl]() {
													goto l117
												}
												if !_rules[rulecomment]() {
													goto l117
												}
												goto l116
											l117:
												position, tokenIndex = position117, tokenIndex117
											}
											if !_rules[rulewsnl]() {
												goto l113
											}
											if !_rules[ruleval]() {
												goto l113
											}
											{
												add(ruleAction25, position)
											}
										l119:
											{
												position120, tokenIndex120 := position, tokenIndex
											l121:
												{
													position122, tokenIndex122 := position, tokenIndex
													if !_rules[rulewsnl]() {
														goto l122
													}
													if !_rules[rulecomment]() {
														goto l122
													}
													goto l121
												l122:
													position, tokenIndex = position122, tokenIndex122
												}
												if !_rules[rulewsnl]() {
													goto l120
												}
												if !_rules[rulearraySep]() {
													goto l120
												}
											l123:
												{
													position124, tokenIndex124 := position, tokenIndex
													if !_rules[rulewsnl]() {
														goto l124
													}
													if !_rules[rulecomment]() {
														goto l124
													}
													goto l123
												l124:
													position, tokenIndex = position124, tokenIndex124
												}
												if !_rules[rulewsnl]() {
													goto l120
												}
												if !_rules[ruleval]() {
													goto l120
												}
												{
													add(ruleAction26, position)
												}
												goto l119
											l120:
												position, tokenIndex = position120, tokenIndex120
											}
										l126:
											{
												position127, tokenIndex127 := position, tokenIndex
												if !_rules[rulewsnl]() {
													goto l127
												}
												if !_rules[rulecomment]() {
													goto l127
												}
												goto l126
											l127:
												position, tokenIndex = position127, tokenIndex127
											}
											if !_rules[rulewsnl]() {
												goto l113
											}
											{
												position128, tokenIndex128 := position, tokenIndex
												if !_rules[rulearraySep]() {
													goto l128
												}
												goto l129
											l128:
												position, tokenIndex = position128, tokenIndex128
											}
										l129:
										l130:
											{
												position131, tokenIndex131 := position, tokenIndex
												if !_rules[rulewsnl]() {
													goto l131
												}
												if !_rules[rulecomment]() {
													goto l131
												}
												goto l130
											l131:
												position, tokenIndex = position131, tokenIndex131
											}
											add(rulearrayValues, position115)
										}
										goto l114
									l113:
										position, tokenIndex = position113, tokenIndex113
									}
								l114:
									if !_rules[rulewsnl]() {
										goto l57
									}
									if buffer[position] != rune(']') {
										goto l57
									}
									position++
									add(rulearray, position111)
								}
								add(rulePegText, position110)
							}
							{
								add(ruleAction8, position)
							}
						case 'f', 't':
							{
								position133 := position
								{
									position134 := position
									{
										position135, tokenIndex135 := position, tokenIndex
										if buffer[position] != rune('t') {
											goto l136
										}
										position++
										if buffer[position] != rune('r') {
											goto l136
										}
										position++
										if buffer[position] != rune('u') {
											goto l136
										}
										position++
										if buffer[position] != rune('e') {
											goto l136
										}
										position++
										goto l135
									l136:
										position, tokenIndex = position135, tokenIndex135
										if buffer[position] != rune('f') {
											goto l57
										}
										position++
										if buffer[position] != rune('a') {
											goto l57
										}
										position++
										if buffer[position] != rune('l') {
											goto l57
										}
										position++
										if buffer[position] != rune('s') {
											goto l57
										}
										position++
										if buffer[position] != rune('e') {
											goto l57
										}
										position++
									}
								l135:
									add(ruleboolean, position134)
								}
								add(rulePegText, position133)
							}
							{
								add(ruleAction7, position)
							}
						case '"', '\'':
							{
								position138 := position
								{
									position139 := position
									{
										position140, tokenIndex140 := position, tokenIndex
										{
											position142 := position
											if buffer[position] != rune('\'') {
												goto l141
											}
											position++
											if buffer[position] != rune('\'') {
												goto l141
											}
											position++
											if buffer[position] != rune('\'') {
												goto l141
											}
											position++
											{
												position143 := position
												{
													position144 := position
												l145:
													{
														position146, tokenIndex146 := position, tokenIndex
														{
															position147, tokenIndex147 := position, tokenIndex
															if buffer[position] != rune('\'') {
																goto l147
															}
															position++
															if buffer[position] != rune('\'') {
																goto l147
															}
															position++
															if buffer[position] != rune('\'') {
																goto l147
															}
															position++
															goto l146
														l147:
															position, tokenIndex = position147, tokenIndex147
														}
														{
															position148, tokenIndex148 := position, tokenIndex
															{
																position150 := position
																{
																	position151, tokenIndex151 := position, tokenIndex
																	if buffer[position] != rune('\t') {
																		goto l152
																	}
																	position++
																	goto l151
																l152:
																	position, tokenIndex = position151, tokenIndex151
																	if c := buffer[position]; c < rune(' ') || c > rune('\U0010ffff') {
																		goto l149
																	}
																	position++
																}
															l151:
																add(rulemlLiteralChar, position150)
															}
															goto l148
														l149:
															position, tokenIndex = position148, tokenIndex148
															if !_rules[rulenewline]() {
																goto l146
															}
														}
													l148:
														goto l145
													l146:
														position, tokenIndex = position146, tokenIndex146
													}
													add(rulemlLiteralBody, position144)
												}
												add(rulePegText, position143)
											}
											if buffer[position] != rune('\'') {
												goto l141
											}
											position++
											if buffer[position] != rune('\'') {
												goto l141
											}
											position++
											if buffer[position] != rune('\'') {
												goto l141
											}
											position++
											{
												add(ruleAction23, position)
											}
											add(rulemlLiteralString, position142)
										}
										goto l140
									l141:
										position, tokenIndex = position140, tokenIndex140
										{
											position155 := position
											if buffer[position] != rune('\'') {
												goto l154
											}
											position++
											{
												position156 := position
											l157:
												{
													position158, tokenIndex158 := position, tokenIndex
													{
														position159 := position
														{
															switch buffer[position] {
															case '\t':
																if buffer[position] != rune('\t') {
																	goto l158
																}
																position++
															case ' ', '!', '"', '#', '$', '%', '&':
																if c := buffer[position]; c < rune(' ') || c > rune('&') {
																	goto l158
																}
																position++
															default:
																if c := buffer[position]; c < rune('(') || c > rune('\U0010ffff') {
																	goto l158
																}
																position++
															}
														}

														add(ruleliteralChar, position159)
													}
													goto l157
												l158:
													position, tokenIndex = position158, tokenIndex158
												}
												add(rulePegText, position156)
											}
											if buffer[position] != rune('\'') {
												goto l154
											}
											position++
											{
												add(ruleAction22, position)
											}
											add(ruleliteralString, position155)
										}
										goto l140
									l154:
										position, tokenIndex = position140, tokenIndex140
										{
											position163 := position
											if buffer[position] != rune('"') {
												goto l162
											}
											position++
											if buffer[position] != rune('"') {
												goto l162
											}
											position++
											if buffer[position] != rune('"') {
												goto l162
											}
											position++
											{
												position164 := position
											l165:
												{
													position166, tokenIndex166 := position, tokenIndex
													{
														position167, tokenIndex167 := position, tokenIndex
														{
															position169, tokenIndex169 := position, tokenIndex
															if buffer[position] != rune('"') {
																goto l169
															}
															position++
															if buffer[position] != rune('"') {
																goto l169
															}
															position++
															if buffer[position] != rune('"') {
																goto l169
															}
															position++
															goto l168
														l169:
															position, tokenIndex = position169, tokenIndex169
														}
														if buffer[position] != rune('"') {
															goto l168
														}
														position++
														{
															add(ruleAction20, position)
														}
														goto l167
													l168:
														position, tokenIndex = position167, tokenIndex167
														{
															position172 := position
															{
																position173, tokenIndex173 := position, tokenIndex
																if !_rules[rulebasicChar]() {
																	goto l174
																}
																goto l173
															l174:
																position, tokenIndex = position173, tokenIndex173
																if !_rules[rulenewline]() {
																	goto l171
																}
															}
														l173:
															add(rulePegText, position172)
														}
														{
															add(ruleAction21, position)
														}
														goto l167
													l171:
														position, tokenIndex = position167, tokenIndex167
														if !_rules[ruleescape]() {
															goto l166
														}
														if !_rules[rulenewline]() {
															goto l166
														}
														if !_rules[rulewsnl]() {
															goto l166
														}
													}
												l167:
													goto l165
												l166:
													position, tokenIndex = position166, tokenIndex166
												}
												add(rulemlBasicBody, position164)
											}
											if buffer[position] != rune('"') {
												goto l162
											}
											position++
											if buffer[position] != rune('"') {
												goto l162
											}
											position++
											if buffer[position] != rune('"') {
												goto l162
											}
											position++
											{
												add(ruleAction19, position)
											}
											add(rulemlBasicString, position163)
										}
										goto l140
									l162:
										position, tokenIndex = position140, tokenIndex140
										{
											position177 := position
											{
												position178 := position
												if buffer[position] != rune('"') {
													goto l57
												}
												position++
											l179:
												{
													position180, tokenIndex180 := position, tokenIndex
													if !_rules[rulebasicChar]() {
														goto l180
													}
													goto l179
												l180:
													position, tokenIndex = position180, tokenIndex180
												}
												if buffer[position] != rune('"') {
													goto l57
												}
												position++
												add(rulePegText, position178)
											}
											{
												add(ruleAction18, position)
											}
											add(rulebasicString, position177)
										}
									}
								l140:
									add(rulestring, position139)
								}
								add(rulePegText, position138)
							}
							{
								add(ruleAction6, position)
							}
						default:
							{
								position183 := position
								{
									position184 := position
									{
										position185, tokenIndex185 := position, tokenIndex
										{
											position187 := position
											if buffer[position] != rune('0') {
												goto l186
											}
											position++
											if buffer[position] != rune('x') {
												goto l186
											}
											position++
											if !_rules[rulehexDigit]() {
												goto l186
											}
										l188:
											{
												position189, tokenIndex189 := position, tokenIndex
												{
													position190, tokenIndex190 := position, tokenIndex
													if !_rules[rulehexDigit]() {
														goto l191
													}
													goto l190
												l191:
													position, tokenIndex = position190, tokenIndex190
													if buffer[position] != rune('_') {
														goto l189
													}
													position++
													if !_rules[rulehexDigit]() {
														goto l189
													}
												}
											l190:
												goto l188
											l189:
												position, tokenIndex = position189, tokenIndex189
											}
											add(rulehexInt, position187)
										}
										goto l185
									l186:
										position, tokenIndex = position185, tokenIndex185
										{
											position193 := position
											if buffer[position] != rune('0') {
												goto l192
											}
											position++
											if buffer[position] != rune('o') {
												goto l192
											}
											position++
											if !_rules[ruleoctalDigit]() {
												goto l192
											}
										l194:
											{
												position195, tokenIndex195 := position, tokenIndex
												{
													position196, tokenIndex196 := position, tokenIndex
													if !_rules[ruleoctalDigit]() {
														goto l197
													}
													goto l196
												l197:
													position, tokenIndex = position196, tokenIndex196
													if buffer[position] != rune('_') {
														goto l195
													}
													position++
													if !_rules[ruleoctalDigit]() {
														goto l195
													}
												}
											l196:
												goto l194
											l195:
												position, tokenIndex = position195, tokenIndex195
											}
											add(ruleoctalInt, position193)
										}
										goto l185
									l192:
										position, tokenIndex = position185, tokenIndex185
										{
											position199 := position
											if buffer[position] != rune('0') {
												goto l198
											}
											position++
											if buffer[position] != rune('b') {
												goto l198
											}
											position++
											if !_rules[rulebinaryDigit]() {
												goto l198
											}
										l200:
											{
												position201, tokenIndex201 := position, tokenIndex
												{
													position202, tokenIndex202 := position, tokenIndex
													if !_rules[rulebinaryDigit]() {
														goto l203
													}
													goto l202
												l203:
													position, tokenIndex = position202, tokenIndex202
													if buffer[position] != rune('_') {
														goto l201
													}
													position++
													if !_rules[ruleoctalDigit]() {
														goto l201
													}
												}
											l202:
												goto l200
											l201:
												position, tokenIndex = position201, tokenIndex201
											}
											add(rulebinaryInt, position199)
										}
										goto l185
									l198:
										position, tokenIndex = position185, tokenIndex185
										if !_rules[ruledecimalInt]() {
											goto l204
										}
										goto l185
									l204:
										position, tokenIndex = position185, tokenIndex185
										{
											position205, tokenIndex205 := position, tokenIndex
											if buffer[position] != rune('+') {
												goto l206
											}
											position++
											goto l205
										l206:
											position, tokenIndex = position205, tokenIndex205
											if buffer[position] != rune('-') {
												goto l57
											}
											position++
										}
									l205:
										if !_rules[ruledecimalInt]() {
											goto l57
										}
									}
								l185:
									add(ruleinteger, position184)
								}
								add(rulePegText, position183)
							}
							{
								add(ruleAction5, position)
							}
						}
					}

				}
			l59:
				add(ruleval, position58)
			}
			return true
		l57:
			position, tokenIndex = position57, tokenIndex57
			return false
		},
		/* 7 table <- <(stdTable / arrayTable)> */
		nil,
		/* 8 stdTable <- <('[' ws <tableKey> ws ']' Action10)> */
		nil,
		/* 9 arrayTable <- <('[' '[' ws <tableKey> ws (']' ']') Action11)> */
		nil,
		/* 10 inlineTable <- <('{' Action12 ws inlineTableKeyValues ws '}' Action13)> */
		nil,
		/* 11 inlineTableKeyValues <- <(keyval inlineTableValSep?)*> */
		nil,
		/* 12 keyval <- <(key ws '=' ws val Action14)> */
		func() bool {
			position213, tokenIndex213 := position, tokenIndex
			{
				position214 := position
				if !_rules[rulekey]() {
					goto l213
				}
				if !_rules[rulews]() {
					goto l213
				}
				if buffer[position] != rune('=') {
					goto l213
				}
				position++
				if !_rules[rulews]() {
					goto l213
				}
				if !_rules[ruleval]() {
					goto l213
				}
				{
					add(ruleAction14, position)
				}
				add(rulekeyval, position214)
			}
			return true
		l213:
			position, tokenIndex = position213, tokenIndex213
			return false
		},
		/* 13 key <- <(bareKey / quotedKey)> */
		func() bool {
			position216, tokenIndex216 := position, tokenIndex
			{
				position217 := position
				{
					position218, tokenIndex218 := position, tokenIndex
					{
						position220 := position
						{
							position221 := position
							{
								switch buffer[position] {
								case '_':
									if buffer[position] != rune('_') {
										goto l219
									}
									position++
								case '-':
									if buffer[position] != rune('-') {
										goto l219
									}
									position++
								case 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z':
									if c := buffer[position]; c < rune('a') || c > rune('z') {
										goto l219
									}
									position++
								case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
									if c := buffer[position]; c < rune('0') || c > rune('9') {
										goto l219
									}
									position++
								default:
									if c := buffer[position]; c < rune('A') || c > rune('Z') {
										goto l219
									}
									position++
								}
							}

						l222:
							{
								position223, tokenIndex223 := position, tokenIndex
								{
									switch buffer[position] {
									case '_':
										if buffer[position] != rune('_') {
											goto l223
										}
										position++
									case '-':
										if buffer[position] != rune('-') {
											goto l223
										}
										position++
									case 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z':
										if c := buffer[position]; c < rune('a') || c > rune('z') {
											goto l223
										}
										position++
									case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
										if c := buffer[position]; c < rune('0') || c > rune('9') {
											goto l223
										}
										position++
									default:
										if c := buffer[position]; c < rune('A') || c > rune('Z') {
											goto l223
										}
										position++
									}
								}

								goto l222
							l223:
								position, tokenIndex = position223, tokenIndex223
							}
							add(rulePegText, position221)
						}
						{
							add(ruleAction15, position)
						}
						add(rulebareKey, position220)
					}
					goto l218
				l219:
					position, tokenIndex = position218, tokenIndex218
					{
						position227 := position
						{
							position228 := position
							if buffer[position] != rune('"') {
								goto l216
							}
							position++
						l229:
							{
								position230, tokenIndex230 := position, tokenIndex
								if !_rules[rulebasicChar]() {
									goto l230
								}
								goto l229
							l230:
								position, tokenIndex = position230, tokenIndex230
							}
							if buffer[position] != rune('"') {
								goto l216
							}
							position++
							add(rulePegText, position228)
						}
						{
							add(ruleAction16, position)
						}
						add(rulequotedKey, position227)
					}
				}
			l218:
				add(rulekey, position217)
			}
			return true
		l216:
			position, tokenIndex = position216, tokenIndex216
			return false
		},
		/* 14 bareKey <- <(<((&('_') '_') | (&('-') '-') | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z]))+> Action15)> */
		nil,
		/* 15 quotedKey <- <(<('"' basicChar* '"')> Action16)> */
		nil,
		/* 16 tableKey <- <(tableKeyComp (tableKeySep tableKeyComp)*)> */
		func() bool {
			position234, tokenIndex234 := position, tokenIndex
			{
				position235 := position
				if !_rules[ruletableKeyComp]() {
					goto l234
				}
			l236:
				{
					position237, tokenIndex237 := position, tokenIndex
					{
						position238 := position
						if !_rules[rulews]() {
							goto l237
						}
						if buffer[position] != rune('.') {
							goto l237
						}
						position++
						if !_rules[rulews]() {
							goto l237
						}
						add(ruletableKeySep, position238)
					}
					if !_rules[ruletableKeyComp]() {
						goto l237
					}
					goto l236
				l237:
					position, tokenIndex = position237, tokenIndex237
				}
				add(ruletableKey, position235)
			}
			return true
		l234:
			position, tokenIndex = position234, tokenIndex234
			return false
		},
		/* 17 tableKeyComp <- <(key Action17)> */
		func() bool {
			position239, tokenIndex239 := position, tokenIndex
			{
				position240 := position
				if !_rules[rulekey]() {
					goto l239
				}
				{
					add(ruleAction17, position)
				}
				add(ruletableKeyComp, position240)
			}
			return true
		l239:
			position, tokenIndex = position239, tokenIndex239
			return false
		},
		/* 18 tableKeySep <- <(ws '.' ws)> */
		nil,
		/* 19 inlineTableValSep <- <(ws ',' ws)> */
		nil,
		/* 20 boolean <- <(('t' 'r' 'u' 'e') / ('f' 'a' 'l' 's' 'e'))> */
		nil,
		/* 21 integer <- <(hexInt / octalInt / binaryInt / decimalInt / (('+' / '-') decimalInt))> */
		nil,
		/* 22 decimalInt <- <(([1-9] (decimalDigit / ('_' decimalDigit))+) / decimalDigit)> */
		func() bool {
			position246, tokenIndex246 := position, tokenIndex
			{
				position247 := position
				{
					position248, tokenIndex248 := position, tokenIndex
					if c := buffer[position]; c < rune('1') || c > rune('9') {
						goto l249
					}
					position++
					{
						position252, tokenIndex252 := position, tokenIndex
						if !_rules[ruledecimalDigit]() {
							goto l253
						}
						goto l252
					l253:
						position, tokenIndex = position252, tokenIndex252
						if buffer[position] != rune('_') {
							goto l249
						}
						position++
						if !_rules[ruledecimalDigit]() {
							goto l249
						}
					}
				l252:
				l250:
					{
						position251, tokenIndex251 := position, tokenIndex
						{
							position254, tokenIndex254 := position, tokenIndex
							if !_rules[ruledecimalDigit]() {
								goto l255
							}
							goto l254
						l255:
							position, tokenIndex = position254, tokenIndex254
							if buffer[position] != rune('_') {
								goto l251
							}
							position++
							if !_rules[ruledecimalDigit]() {
								goto l251
							}
						}
					l254:
						goto l250
					l251:
						position, tokenIndex = position251, tokenIndex251
					}
					goto l248
				l249:
					position, tokenIndex = position248, tokenIndex248
					if !_rules[ruledecimalDigit]() {
						goto l246
					}
				}
			l248:
				add(ruledecimalInt, position247)
			}
			return true
		l246:
			position, tokenIndex = position246, tokenIndex246
			return false
		},
		/* 23 decimalDigit <- <[0-9]> */
		func() bool {
			position256, tokenIndex256 := position, tokenIndex
			{
				position257 := position
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l256
				}
				position++
				add(ruledecimalDigit, position257)
			}
			return true
		l256:
			position, tokenIndex = position256, tokenIndex256
			return false
		},
		/* 24 hexInt <- <('0' 'x' hexDigit (hexDigit / ('_' hexDigit))*)> */
		nil,
		/* 25 hexDigit <- <((&('a' | 'b' | 'c' | 'd' | 'e' | 'f') [a-f]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F') [A-F]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]))> */
		func() bool {
			position259, tokenIndex259 := position, tokenIndex
			{
				position260 := position
				{
					switch buffer[position] {
					case 'a', 'b', 'c', 'd', 'e', 'f':
						if c := buffer[position]; c < rune('a') || c > rune('f') {
							goto l259
						}
						position++
					case 'A', 'B', 'C', 'D', 'E', 'F':
						if c := buffer[position]; c < rune('A') || c > rune('F') {
							goto l259
						}
						position++
					default:
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l259
						}
						position++
					}
				}

				add(rulehexDigit, position260)
			}
			return true
		l259:
			position, tokenIndex = position259, tokenIndex259
			return false
		},
		/* 26 octalInt <- <('0' 'o' octalDigit (octalDigit / ('_' octalDigit))*)> */
		nil,
		/* 27 octalDigit <- <[0-7]> */
		func() bool {
			position263, tokenIndex263 := position, tokenIndex
			{
				position264 := position
				if c := buffer[position]; c < rune('0') || c > rune('7') {
					goto l263
				}
				position++
				add(ruleoctalDigit, position264)
			}
			return true
		l263:
			position, tokenIndex = position263, tokenIndex263
			return false
		},
		/* 28 binaryInt <- <('0' 'b' binaryDigit (binaryDigit / ('_' octalDigit))*)> */
		nil,
		/* 29 binaryDigit <- <('0' / '1')> */
		func() bool {
			position266, tokenIndex266 := position, tokenIndex
			{
				position267 := position
				{
					position268, tokenIndex268 := position, tokenIndex
					if buffer[position] != rune('0') {
						goto l269
					}
					position++
					goto l268
				l269:
					position, tokenIndex = position268, tokenIndex268
					if buffer[position] != rune('1') {
						goto l266
					}
					position++
				}
			l268:
				add(rulebinaryDigit, position267)
			}
			return true
		l266:
			position, tokenIndex = position266, tokenIndex266
			return false
		},
		/* 30 float <- <(('+' / '-')? ((&('i') ('i' 'n' 'f')) | (&('n') ('n' 'a' 'n')) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') floatDigits)))> */
		nil,
		/* 31 floatDigits <- <(decimalInt ((floatFrac floatExp?) / (floatFrac? floatExp)))> */
		nil,
		/* 32 floatFrac <- <('.' decimalDigit (decimalDigit / ('_' decimalDigit))*)> */
		func() bool {
			position272, tokenIndex272 := position, tokenIndex
			{
				position273 := position
				if buffer[position] != rune('.') {
					goto l272
				}
				position++
				if !_rules[ruledecimalDigit]() {
					goto l272
				}
			l274:
				{
					position275, tokenIndex275 := position, tokenIndex
					{
						position276, tokenIndex276 := position, tokenIndex
						if !_rules[ruledecimalDigit]() {
							goto l277
						}
						goto l276
					l277:
						position, tokenIndex = position276, tokenIndex276
						if buffer[position] != rune('_') {
							goto l275
						}
						position++
						if !_rules[ruledecimalDigit]() {
							goto l275
						}
					}
				l276:
					goto l274
				l275:
					position, tokenIndex = position275, tokenIndex275
				}
				add(rulefloatFrac, position273)
			}
			return true
		l272:
			position, tokenIndex = position272, tokenIndex272
			return false
		},
		/* 33 floatExp <- <(('e' / 'E') ('-' / '+')? decimalDigit (decimalDigit / ('_' decimalDigit))*)> */
		func() bool {
			position278, tokenIndex278 := position, tokenIndex
			{
				position279 := position
				{
					position280, tokenIndex280 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l281
					}
					position++
					goto l280
				l281:
					position, tokenIndex = position280, tokenIndex280
					if buffer[position] != rune('E') {
						goto l278
					}
					position++
				}
			l280:
				{
					position282, tokenIndex282 := position, tokenIndex
					{
						position284, tokenIndex284 := position, tokenIndex
						if buffer[position] != rune('-') {
							goto l285
						}
						position++
						goto l284
					l285:
						position, tokenIndex = position284, tokenIndex284
						if buffer[position] != rune('+') {
							goto l282
						}
						position++
					}
				l284:
					goto l283
				l282:
					position, tokenIndex = position282, tokenIndex282
				}
			l283:
				if !_rules[ruledecimalDigit]() {
					goto l278
				}
			l286:
				{
					position287, tokenIndex287 := position, tokenIndex
					{
						position288, tokenIndex288 := position, tokenIndex
						if !_rules[ruledecimalDigit]() {
							goto l289
						}
						goto l288
					l289:
						position, tokenIndex = position288, tokenIndex288
						if buffer[position] != rune('_') {
							goto l287
						}
						position++
						if !_rules[ruledecimalDigit]() {
							goto l287
						}
					}
				l288:
					goto l286
				l287:
					position, tokenIndex = position287, tokenIndex287
				}
				add(rulefloatExp, position279)
			}
			return true
		l278:
			position, tokenIndex = position278, tokenIndex278
			return false
		},
		/* 34 escaped <- <(escape ((&('U') ('U' hexQuad hexQuad)) | (&('u') ('u' hexQuad)) | (&('\\') '\\') | (&('/') '/') | (&('"') '"') | (&('r') 'r') | (&('f') 'f') | (&('n') 'n') | (&('t') 't') | (&('b') 'b')))> */
		nil,
		/* 35 escape <- <'\\'> */
		func() bool {
			position291, tokenIndex291 := position, tokenIndex
			{
				position292 := position
				if buffer[position] != rune('\\') {
					goto l291
				}
				position++
				add(ruleescape, position292)
			}
			return true
		l291:
			position, tokenIndex = position291, tokenIndex291
			return false
		},
		/* 36 hexQuad <- <(hexDigit hexDigit hexDigit hexDigit)> */
		func() bool {
			position293, tokenIndex293 := position, tokenIndex
			{
				position294 := position
				if !_rules[rulehexDigit]() {
					goto l293
				}
				if !_rules[rulehexDigit]() {
					goto l293
				}
				if !_rules[rulehexDigit]() {
					goto l293
				}
				if !_rules[rulehexDigit]() {
					goto l293
				}
				add(rulehexQuad, position294)
			}
			return true
		l293:
			position, tokenIndex = position293, tokenIndex293
			return false
		},
		/* 37 string <- <(mlLiteralString / literalString / mlBasicString / basicString)> */
		nil,
		/* 38 basicString <- <(<('"' basicChar* '"')> Action18)> */
		nil,
		/* 39 basicChar <- <(basicUnescaped / escaped)> */
		func() bool {
			position297, tokenIndex297 := position, tokenIndex
			{
				position298 := position
				{
					position299, tokenIndex299 := position, tokenIndex
					{
						position301 := position
						{
							switch buffer[position] {
							case '\t':
								if buffer[position] != rune('\t') {
									goto l300
								}
								position++
							case ' ', '!':
								if c := buffer[position]; c < rune(' ') || c > rune('!') {
									goto l300
								}
								position++
							case '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[':
								if c := buffer[position]; c < rune('#') || c > rune('[') {
									goto l300
								}
								position++
							default:
								if c := buffer[position]; c < rune(']') || c > rune('\U0010ffff') {
									goto l300
								}
								position++
							}
						}

						add(rulebasicUnescaped, position301)
					}
					goto l299
				l300:
					position, tokenIndex = position299, tokenIndex299
					{
						position303 := position
						if !_rules[ruleescape]() {
							goto l297
						}
						{
							switch buffer[position] {
							case 'U':
								if buffer[position] != rune('U') {
									goto l297
								}
								position++
								if !_rules[rulehexQuad]() {
									goto l297
								}
								if !_rules[rulehexQuad]() {
									goto l297
								}
							case 'u':
								if buffer[position] != rune('u') {
									goto l297
								}
								position++
								if !_rules[rulehexQuad]() {
									goto l297
								}
							case '\\':
								if buffer[position] != rune('\\') {
									goto l297
								}
								position++
							case '/':
								if buffer[position] != rune('/') {
									goto l297
								}
								position++
							case '"':
								if buffer[position] != rune('"') {
									goto l297
								}
								position++
							case 'r':
								if buffer[position] != rune('r') {
									goto l297
								}
								position++
							case 'f':
								if buffer[position] != rune('f') {
									goto l297
								}
								position++
							case 'n':
								if buffer[position] != rune('n') {
									goto l297
								}
								position++
							case 't':
								if buffer[position] != rune('t') {
									goto l297
								}
								position++
							default:
								if buffer[position] != rune('b') {
									goto l297
								}
								position++
							}
						}

						add(ruleescaped, position303)
					}
				}
			l299:
				add(rulebasicChar, position298)
			}
			return true
		l297:
			position, tokenIndex = position297, tokenIndex297
			return false
		},
		/* 40 basicUnescaped <- <((&('\t') '\t') | (&(' ' | '!') [ -!]) | (&('#' | '$' | '%' | '&' | '\'' | '(' | ')' | '*' | '+' | ',' | '-' | '.' | '/' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | ':' | ';' | '<' | '=' | '>' | '?' | '@' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | '[') [#-[]) | (&(']' | '^' | '_' | '`' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' | '{' | '|' | '}' | '~' | '\u007f' | '\u0080' | '\u0081' | '\u0082' | '\u0083' | '\u0084' | '\u0085' | '\u0086' | '\u0087' | '\u0088' | '\u0089' | '\u008a' | '\u008b' | '\u008c' | '\u008d' | '\u008e' | '\u008f' | '\u0090' | '\u0091' | '\u0092' | '\u0093' | '\u0094' | '\u0095' | '\u0096' | '\u0097' | '\u0098' | '\u0099' | '\u009a' | '\u009b' | '\u009c' | '\u009d' | '\u009e' | '\u009f' | '\u00a0' | '¡' | '¢' | '£' | '¤' | '¥' | '¦' | '§' | '¨' | '©' | 'ª' | '«' | '¬' | '\u00ad' | '®' | '¯' | '°' | '±' | '²' | '³' | '´' | 'µ' | '¶' | '·' | '¸' | '¹' | 'º' | '»' | '¼' | '½' | '¾' | '¿' | 'À' | 'Á' | 'Â' | 'Ã' | 'Ä' | 'Å' | 'Æ' | 'Ç' | 'È' | 'É' | 'Ê' | 'Ë' | 'Ì' | 'Í' | 'Î' | 'Ï' | 'Ð' | 'Ñ' | 'Ò' | 'Ó' | 'Ô' | 'Õ' | 'Ö' | '×' | 'Ø' | 'Ù' | 'Ú' | 'Û' | 'Ü' | 'Ý' | 'Þ' | 'ß' | 'à' | 'á' | 'â' | 'ã' | 'ä' | 'å' | 'æ' | 'ç' | 'è' | 'é' | 'ê' | 'ë' | 'ì' | 'í' | 'î' | 'ï' | 'ð' | 'ñ' | 'ò' | 'ó' | 'ô' | 'õ' | 'ö' | '÷' | 'ø' | 'ù' | 'ú' | 'û' | 'ü' | 'ý' | 'þ' | 'ÿ') []-\U0010ffff]))> */
		nil,
		/* 41 mlBasicString <- <('"' '"' '"' mlBasicBody ('"' '"' '"') Action19)> */
		nil,
		/* 42 mlBasicBody <- <((!('"' '"' '"') '"' Action20) / (<(basicChar / newline)> Action21) / (escape newline wsnl))*> */
		nil,
		/* 43 literalString <- <('\'' <literalChar*> '\'' Action22)> */
		nil,
		/* 44 literalChar <- <((&('\t') '\t') | (&(' ' | '!' | '"' | '#' | '$' | '%' | '&') [ -&]) | (&('(' | ')' | '*' | '+' | ',' | '-' | '.' | '/' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | ':' | ';' | '<' | '=' | '>' | '?' | '@' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | '[' | '\\' | ']' | '^' | '_' | '`' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' | '{' | '|' | '}' | '~' | '\u007f' | '\u0080' | '\u0081' | '\u0082' | '\u0083' | '\u0084' | '\u0085' | '\u0086' | '\u0087' | '\u0088' | '\u0089' | '\u008a' | '\u008b' | '\u008c' | '\u008d' | '\u008e' | '\u008f' | '\u0090' | '\u0091' | '\u0092' | '\u0093' | '\u0094' | '\u0095' | '\u0096' | '\u0097' | '\u0098' | '\u0099' | '\u009a' | '\u009b' | '\u009c' | '\u009d' | '\u009e' | '\u009f' | '\u00a0' | '¡' | '¢' | '£' | '¤' | '¥' | '¦' | '§' | '¨' | '©' | 'ª' | '«' | '¬' | '\u00ad' | '®' | '¯' | '°' | '±' | '²' | '³' | '´' | 'µ' | '¶' | '·' | '¸' | '¹' | 'º' | '»' | '¼' | '½' | '¾' | '¿' | 'À' | 'Á' | 'Â' | 'Ã' | 'Ä' | 'Å' | 'Æ' | 'Ç' | 'È' | 'É' | 'Ê' | 'Ë' | 'Ì' | 'Í' | 'Î' | 'Ï' | 'Ð' | 'Ñ' | 'Ò' | 'Ó' | 'Ô' | 'Õ' | 'Ö' | '×' | 'Ø' | 'Ù' | 'Ú' | 'Û' | 'Ü' | 'Ý' | 'Þ' | 'ß' | 'à' | 'á' | 'â' | 'ã' | 'ä' | 'å' | 'æ' | 'ç' | 'è' | 'é' | 'ê' | 'ë' | 'ì' | 'í' | 'î' | 'ï' | 'ð' | 'ñ' | 'ò' | 'ó' | 'ô' | 'õ' | 'ö' | '÷' | 'ø' | 'ù' | 'ú' | 'û' | 'ü' | 'ý' | 'þ' | 'ÿ') [(-\U0010ffff]))> */
		nil,
		/* 45 mlLiteralString <- <('\'' '\'' '\'' <mlLiteralBody> ('\'' '\'' '\'') Action23)> */
		nil,
		/* 46 mlLiteralBody <- <(!('\'' '\'' '\'') (mlLiteralChar / newline))*> */
		nil,
		/* 47 mlLiteralChar <- <('\t' / [ -\U0010ffff])> */
		nil,
		/* 48 dateFullYear <- <digitQuad> */
		nil,
		/* 49 dateMonth <- <digitDual> */
		nil,
		/* 50 dateMDay <- <digitDual> */
		nil,
		/* 51 timeHour <- <digitDual> */
		func() bool {
			position316, tokenIndex316 := position, tokenIndex
			{
				position317 := position
				if !_rules[ruledigitDual]() {
					goto l316
				}
				add(ruletimeHour, position317)
			}
			return true
		l316:
			position, tokenIndex = position316, tokenIndex316
			return false
		},
		/* 52 timeMinute <- <digitDual> */
		func() bool {
			position318, tokenIndex318 := position, tokenIndex
			{
				position319 := position
				if !_rules[ruledigitDual]() {
					goto l318
				}
				add(ruletimeMinute, position319)
			}
			return true
		l318:
			position, tokenIndex = position318, tokenIndex318
			return false
		},
		/* 53 timeSecond <- <digitDual> */
		nil,
		/* 54 timeSecfrac <- <('.' decimalDigit+)> */
		nil,
		/* 55 timeNumoffset <- <(('-' / '+') timeHour ':' timeMinute)> */
		nil,
		/* 56 timeOffset <- <((&('z') 'z') | (&('Z') 'Z') | (&('+' | '-') timeNumoffset))> */
		nil,
		/* 57 partialTime <- <(timeHour ':' timeMinute ':' timeSecond timeSecfrac?)> */
		func() bool {
			position324, tokenIndex324 := position, tokenIndex
			{
				position325 := position
				if !_rules[ruletimeHour]() {
					goto l324
				}
				if buffer[position] != rune(':') {
					goto l324
				}
				position++
				if !_rules[ruletimeMinute]() {
					goto l324
				}
				if buffer[position] != rune(':') {
					goto l324
				}
				position++
				{
					position326 := position
					if !_rules[ruledigitDual]() {
						goto l324
					}
					add(ruletimeSecond, position326)
				}
				{
					position327, tokenIndex327 := position, tokenIndex
					{
						position329 := position
						if buffer[position] != rune('.') {
							goto l327
						}
						position++
						if !_rules[ruledecimalDigit]() {
							goto l327
						}
					l330:
						{
							position331, tokenIndex331 := position, tokenIndex
							if !_rules[ruledecimalDigit]() {
								goto l331
							}
							goto l330
						l331:
							position, tokenIndex = position331, tokenIndex331
						}
						add(ruletimeSecfrac, position329)
					}
					goto l328
				l327:
					position, tokenIndex = position327, tokenIndex327
				}
			l328:
				add(rulepartialTime, position325)
			}
			return true
		l324:
			position, tokenIndex = position324, tokenIndex324
			return false
		},
		/* 58 fullDate <- <(dateFullYear '-' dateMonth '-' dateMDay)> */
		nil,
		/* 59 fullTime <- <(partialTime timeOffset?)> */
		nil,
		/* 60 datetime <- <((fullDate (((&(' ') ' ') | (&('t') 't') | (&('T') 'T')) fullTime)?) / partialTime)> */
		nil,
		/* 61 digitDual <- <(decimalDigit decimalDigit)> */
		func() bool {
			position335, tokenIndex335 := position, tokenIndex
			{
				position336 := position
				if !_rules[ruledecimalDigit]() {
					goto l335
				}
				if !_rules[ruledecimalDigit]() {
					goto l335
				}
				add(ruledigitDual, position336)
			}
			return true
		l335:
			position, tokenIndex = position335, tokenIndex335
			return false
		},
		/* 62 digitQuad <- <(digitDual digitDual)> */
		nil,
		/* 63 array <- <('[' Action24 wsnl arrayValues? wsnl ']')> */
		nil,
		/* 64 arrayValues <- <((wsnl comment)* wsnl val Action25 ((wsnl comment)* wsnl arraySep (wsnl comment)* wsnl val Action26)* (wsnl comment)* wsnl arraySep? (wsnl comment)*)> */
		nil,
		/* 65 arraySep <- <','> */
		func() bool {
			position340, tokenIndex340 := position, tokenIndex
			{
				position341 := position
				if buffer[position] != rune(',') {
					goto l340
				}
				position++
				add(rulearraySep, position341)
			}
			return true
		l340:
			position, tokenIndex = position340, tokenIndex340
			return false
		},
		/* 67 Action0 <- <{ _ = buffer }> */
		nil,
		nil,
		/* 69 Action1 <- <{ p.SetTableSource(begin, end) }> */
		nil,
		/* 70 Action2 <- <{ p.Newline() }> */
		nil,
		/* 71 Action3 <- <{ p.SetTime(begin, end) }> */
		nil,
		/* 72 Action4 <- <{ p.SetFloat(begin, end) }> */
		nil,
		/* 73 Action5 <- <{ p.SetInteger(begin, end) }> */
		nil,
		/* 74 Action6 <- <{ p.SetString(begin, end) }> */
		nil,
		/* 75 Action7 <- <{ p.SetBool(begin, end) }> */
		nil,
		/* 76 Action8 <- <{ p.SetArray(begin, end) }> */
		nil,
		/* 77 Action9 <- <{ p.SetInlineTableSource(begin, end) }> */
		nil,
		/* 78 Action10 <- <{ p.SetTable(p.buffer, begin, end) }> */
		nil,
		/* 79 Action11 <- <{ p.SetArrayTable(p.buffer, begin, end) }> */
		nil,
		/* 80 Action12 <- <{ p.StartInlineTable() }> */
		nil,
		/* 81 Action13 <- <{ p.EndInlineTable() }> */
		nil,
		/* 82 Action14 <- <{ p.AddKeyValue() }> */
		nil,
		/* 83 Action15 <- <{ p.SetKey(p.buffer, begin, end) }> */
		nil,
		/* 84 Action16 <- <{ p.SetKey(p.buffer, begin, end) }> */
		nil,
		/* 85 Action17 <- <{ p.AddTableKey() }> */
		nil,
		/* 86 Action18 <- <{ p.SetBasicString(p.buffer, begin, end) }> */
		nil,
		/* 87 Action19 <- <{ p.SetMultilineBasicString() }> */
		nil,
		/* 88 Action20 <- <{ p.AddMultilineBasicQuote() }> */
		nil,
		/* 89 Action21 <- <{ p.AddMultilineBasicBody(p.buffer, begin, end) }> */
		nil,
		/* 90 Action22 <- <{ p.SetLiteralString(p.buffer, begin, end) }> */
		nil,
		/* 91 Action23 <- <{ p.SetMultilineLiteralString(p.buffer, begin, end) }> */
		nil,
		/* 92 Action24 <- <{ p.StartArray() }> */
		nil,
		/* 93 Action25 <- <{ p.AddArrayVal() }> */
		nil,
		/* 94 Action26 <- <{ p.AddArrayVal() }> */
		nil,
	}
	p.rules = _rules
	return nil
}
