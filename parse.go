package toml

import (
	"errors"
	"fmt"
	"strconv"
	"strings"

	"github.com/naoina/toml/ast"
)

// The parser is generated by github.com/pointlander/peg. To regenerate it, do:
//
//     go get -u github.com/pointlander/peg
//     go generate .

//go:generate peg -switch -inline parse.peg

var (
	errParse                    = errors.New("invalid TOML syntax")
	errNewlineRequired          = errors.New("newline required in table")
	errInlineTableCommaRequired = errors.New("missing ',' in inline table")
	errInlineTableCommaAtEnd    = errors.New("inline table cannot contain ',' after last key/value pair")
)

var (
	underscoreReplacer = strings.NewReplacer("_", "")
	timeLetterReplacer = strings.NewReplacer("z", "Z", "t", "T")
	escapeReplacer     = strings.NewReplacer(
		"\b", "\\n",
		"\f", "\\f",
		"\n", "\\n",
		"\r", "\\r",
		"\t", "\\t",
	)
)

// Parse returns an AST representation of TOML.
// The toplevel is represented by a table.
func Parse(data []byte) (*ast.Table, error) {
	d := &parseState{p: &tomlParser{Buffer: string(data)}}
	d.init()

	if err := d.parse(); err != nil {
		return nil, err
	}

	return d.p.toml.topTable, nil
}

type parseState struct {
	p *tomlParser
}

func (d *parseState) init() {
	d.p.Init()
	d.p.toml.init(d.p.buffer)
}

func (d *parseState) parse() error {
	if err := d.p.Parse(); err != nil {
		if err, ok := err.(*parseError); ok {
			return lineError(err.Line(), errParse)
			// return lineError(err.Line(), errors.New("parse error:\n"+d.p.SprintSyntaxTree()))
		}
		return err
	}
	return d.execute()
}

func (d *parseState) execute() (err error) {
	defer func() {
		if e := recover(); e != nil {
			lerr, ok := e.(*LineError)
			if !ok {
				panic(e)
			}
			err = lerr
		}
	}()
	d.p.Execute()
	return nil
}

func (e *parseError) Line() int {
	tokens := []token32{e.max}
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	for _, t := range translatePositions(e.p.buffer, positions) {
		if e.p.line < t.line {
			e.p.line = t.line
		}
	}
	return e.p.line
}

type tabStackElem struct {
	key   string
	table *ast.Table
}

type array struct {
	parent *array
	child  *array
	a      ast.Array
	line   int
}

type toml struct {
	topTable    *ast.Table      // the top-level table
	line        int             // the current line number
	curTable    *ast.Table      // the current table
	curArray    *array          // the current array
	stringBuf   string          // temporary buffer for string values
	key         string          // the current table key
	tableKeyAcc []string        // accumulator for dotted keys
	val         ast.Value       // last decoded value
	tabStack    []*tabStackElem // table stack (for inline tables)
}

func (p *toml) init(data []rune) {
	p.line = 1
	p.topTable = p.newTable(ast.TableTypeNormal, "")
	p.topTable.Position.End = len(data) - 1
	p.topTable.Data = data[:len(data)-1] // truncate the end_symbol added by PEG parse generator.
	p.curTable = p.topTable
}

func (p *toml) Error(err error) {
	panic(lineError(p.line, err))
}

// Newline is called whenever the parser moves to a new line.
func (p *toml) Newline() {
	p.line++
}

// -- Primitive Value Callbacks --

func (p *tomlParser) SetTime(begin, end int) {
	// Make value compatible with time.Parse.
	v := timeLetterReplacer.Replace(string(p.buffer[begin:end]))
	p.val = &ast.Datetime{
		Position: ast.Position{Begin: begin, End: end},
		Data:     p.buffer[begin:end],
		Value:    v,
	}
}

func (p *tomlParser) SetFloat(begin, end int) {
	// Make value compatible with strconv.ParseFloat.
	v := underscoreReplacer.Replace(string(p.buffer[begin:end]))
	if v == "+nan" || v == "-nan" {
		v = "nan"
	}
	p.val = &ast.Float{
		Position: ast.Position{Begin: begin, End: end},
		Data:     p.buffer[begin:end],
		Value:    v,
	}
}

func (p *tomlParser) SetInteger(begin, end int) {
	p.val = &ast.Integer{
		Position: ast.Position{Begin: begin, End: end},
		Data:     p.buffer[begin:end],
		Value:    underscoreReplacer.Replace(string(p.buffer[begin:end])),
	}
}

func (p *tomlParser) SetString(begin, end int) {
	p.val = &ast.String{
		Position: ast.Position{Begin: begin, End: end},
		Data:     p.buffer[begin:end],
		Value:    p.stringBuf,
	}
	p.stringBuf = ""
}

func (p *tomlParser) SetBool(begin, end int) {
	p.val = &ast.Boolean{
		Position: ast.Position{Begin: begin, End: end},
		Data:     p.buffer[begin:end],
		Value:    string(p.buffer[begin:end]),
	}
}

// -- String Callbacks --
//
// These run during string parsing and build up the string in p.stringBuf.

func (p *toml) SetBasicString(buf []rune, begin, end int) {
	p.stringBuf = p.unquote(string(buf[begin:end]))
}

func (p *toml) SetMultilineBasicString() {
	p.stringBuf = p.unquote(`"` + escapeReplacer.Replace(strings.TrimLeft(p.stringBuf, "\r\n")) + `"`)
}

func (p *toml) AddMultilineBasicBody(buf []rune, begin, end int) {
	p.stringBuf += string(buf[begin:end])
}

func (p *toml) AddMultilineBasicQuote() {
	p.stringBuf += "\\\""
}

func (p *toml) SetLiteralString(buf []rune, begin, end int) {
	p.stringBuf = string(buf[begin:end])
}

func (p *toml) SetMultilineLiteralString(buf []rune, begin, end int) {
	p.stringBuf = strings.TrimLeft(string(buf[begin:end]), "\r\n")
}

func (p *toml) unquote(s string) string {
	s, err := strconv.Unquote(s)
	if err != nil {
		p.Error(err)
	}
	return s
}

// -- Array Callbacks --
//
// These callbacks maintain the array stack and accumulate elements.

func (p *toml) StartArray() {
	if p.curArray == nil {
		p.curArray = &array{line: p.line}
		return
	}
	p.curArray.child = &array{parent: p.curArray, line: p.line}
	p.curArray = p.curArray.child
}

func (p *toml) AddArrayVal() {
	p.curArray.a.Value = append(p.curArray.a.Value, p.val)
}

func (p *tomlParser) SetArray(begin, end int) {
	p.curArray.a.Position = ast.Position{Begin: begin, End: end}
	p.curArray.a.Data = p.buffer[begin:end]
	p.val = &p.curArray.a
	p.curArray = p.curArray.parent
}

// -- Table Callbacks --

func (p *toml) SetTable(buf []rune, begin, end int) {
	rawName := string(buf[begin:end])
	p.setTable(p.topTable, rawName, p.tableKeyAcc)
	p.tableKeyAcc = nil
}

func (p *toml) setTable(parent *ast.Table, name string, names []string) {
	parent, err := p.lookupTable(parent, names[:len(names)-1])
	if err != nil {
		p.Error(err)
	}
	last := names[len(names)-1]
	tbl := p.newTable(ast.TableTypeNormal, last)
	switch v := parent.Fields[last].(type) {
	case nil:
		parent.Fields[last] = tbl
	case []*ast.Table:
		p.Error(fmt.Errorf("table `%s' is in conflict with array table in line %d", name, v[0].Line))
	case *ast.Table:
		if (v.Position == ast.Position{}) {
			// This table was created as an implicit parent.
			// Replace it with the real defined table.
			tbl.Fields = v.Fields
			parent.Fields[last] = tbl
		} else {
			p.Error(fmt.Errorf("table `%s' is in conflict with table in line %d", name, v.Line))
		}
	case *ast.KeyValue:
		p.Error(fmt.Errorf("table `%s' is in conflict with line %d", name, v.Line))
	default:
		p.Error(fmt.Errorf("BUG: table `%s' is in conflict but it's unknown type `%T'", last, v))
	}
	p.curTable = tbl
}

func (p *toml) newTable(typ ast.TableType, name string) *ast.Table {
	return &ast.Table{
		Line:   p.line,
		Name:   name,
		Type:   typ,
		Fields: make(map[string]interface{}),
	}
}

func (p *toml) lookupTable(t *ast.Table, keys []string) (*ast.Table, error) {
	for _, s := range keys {
		val, exists := t.Fields[s]
		if !exists {
			tbl := p.newTable(ast.TableTypeNormal, s)
			t.Fields[s] = tbl
			t = tbl
			continue
		}
		switch v := val.(type) {
		case *ast.Table:
			t = v
		case []*ast.Table:
			t = v[len(v)-1]
		case *ast.KeyValue:
			return nil, fmt.Errorf("key `%s' is in conflict with line %d", s, v.Line)
		default:
			return nil, fmt.Errorf("BUG: key `%s' is in conflict but it's unknown type `%T'", s, v)
		}
	}
	return t, nil
}

// SetTableSource assigns the source data of a complete table.
func (p *tomlParser) SetTableSource(begin, end int) {
	p.curTable.Data = p.buffer[begin:end]
	p.curTable.Position.Begin = begin
	p.curTable.Position.End = end
}

func (p *toml) AddTableKey() {
	p.tableKeyAcc = append(p.tableKeyAcc, p.key)
}

// SetKey is called after a table key has been parsed.
func (p *toml) SetKey(buf []rune, begin, end int) {
	p.key = string(buf[begin:end])
	if len(p.key) > 0 && p.key[0] == '"' {
		p.key = p.unquote(p.key)
	}
}

// AddKeyValue is called after a complete key/value pair has been parsed.
func (p *toml) AddKeyValue() {
	if val, exists := p.curTable.Fields[p.key]; exists {
		switch v := val.(type) {
		case []*ast.Table:
			p.Error(fmt.Errorf("key `%s' is in conflict with array table in line %d", p.key, v[0].Line))
		case *ast.Table:
			p.Error(fmt.Errorf("key `%s' is in conflict with table in line %d", p.key, v.Line))
		case *ast.KeyValue:
			p.Error(fmt.Errorf("key `%s' is in conflict with line %d", p.key, v.Line))
		default:
			p.Error(fmt.Errorf("BUG: key `%s' is in conflict but it's unknown type `%T'", p.key, v))
		}
	}
	p.curTable.Fields[p.key] = &ast.KeyValue{Key: p.key, Value: p.val, Line: p.line}
}

// -- Array Table Callbacks --

func (p *toml) SetArrayTable(buf []rune, begin, end int) {
	rawName := string(buf[begin:end])
	p.setArrayTable(p.topTable, rawName, p.tableKeyAcc)
	p.tableKeyAcc = nil
}

func (p *toml) setArrayTable(parent *ast.Table, name string, names []string) {
	parent, err := p.lookupTable(parent, names[:len(names)-1])
	if err != nil {
		p.Error(err)
	}
	last := names[len(names)-1]
	tbl := p.newTable(ast.TableTypeArray, last)
	switch v := parent.Fields[last].(type) {
	case nil:
		parent.Fields[last] = []*ast.Table{tbl}
	case []*ast.Table:
		parent.Fields[last] = append(v, tbl)
	case *ast.Table:
		p.Error(fmt.Errorf("array table `%s' is in conflict with table in line %d", name, v.Line))
	case *ast.KeyValue:
		p.Error(fmt.Errorf("array table `%s' is in conflict with line %d", name, v.Line))
	default:
		p.Error(fmt.Errorf("BUG: array table `%s' is in conflict but it's unknown type `%T'", name, v))
	}
	p.curTable = tbl
}

// -- Inline Table Callbacks --

func (p *toml) StartInlineTable() {
	tbl := p.newTable(ast.TableTypeInline, "")
	p.tabStack = append(p.tabStack, &tabStackElem{p.key, p.curTable})
	p.curTable = tbl
}

func (p *toml) EndInlineTable() {
	p.val = p.curTable

	// Restore parent table from stack.
	st := p.tabStack[len(p.tabStack)-1]
	p.key, p.curTable = st.key, st.table
	p.tabStack = p.tabStack[:len(p.tabStack)-1]
}

// SetInlineTableSource sets the source data of an inline table.
// This is called just after parsing the table value, when the table
// is still in p.val.
func (p *tomlParser) SetInlineTableSource(begin, end int) {
	tbl := p.val.(*ast.Table)
	tbl.Data = p.buffer[begin:end]
	tbl.Position.Begin = begin
	tbl.Position.End = end
}
