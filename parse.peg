package toml

type tomlParser Peg {
    toml
}

TOML <- Expression (newline Expression)* newline* !. { _ = buffer }

Expression <- (
    <ws table ws comment? (wsnl keyval ws comment?)*> { p.SetTableSource(begin, end) }
  / ws keyval ws comment?
  / ws comment?
  / ws
)

newline <- ('\r\n' / '\n') { p.Newline() }

ws <- [ \t]*

wsnl <- ([ \t] / newline)*

comment <- '#' <[\t -\0x10FFFF]*>

val <- (
    <datetime>    { p.SetTime(begin, end) }
  / <float>       { p.SetFloat(begin, end) }
  / <integer>     { p.SetInteger(begin, end) }
  / <string>      { p.SetString(begin, end) }
  / <boolean>     { p.SetBool(begin, end) }
  / <array>       { p.SetArray(begin, end) }
  / <inlineTable> { p.SetInlineTableSource(begin, end) }
)

# -------------------------------------------------------------------------
# -- Tables

table <- stdTable / arrayTable

stdTable <- '[' ws <tableKey> ws ']' { p.SetTable(p.buffer, begin, end) }

arrayTable <- '[[' ws <tableKey> ws ']]' { p.SetArrayTable(p.buffer, begin, end) }

inlineTable <- (
    '{' { p.StartInlineTable() }
    ws inlineTableKeyValues ws
    '}' { p.EndInlineTable() }
)

inlineTableKeyValues <- (keyval inlineTableValSep?)*

keyval <- key ws '=' ws val { p.AddKeyValue() }

key <- bareKey / quotedKey

bareKey <- <[0-9A-Za-z\-_]+> { p.SetKey(p.buffer, begin, end) }

quotedKey <- < '"' basicChar* '"' > { p.SetKey(p.buffer, begin, end) }

tableKey <- tableKeyComp (tableKeySep tableKeyComp)*

tableKeyComp <- key { p.AddTableKey() }

tableKeySep <- ws '.' ws

inlineTableValSep <- ws ',' ws

# -------------------------------------------------------------------------
# -- Booleans

boolean <- 'true' / 'false'

# -------------------------------------------------------------------------
# -- Numbers

integer <- ('+' decimalInt) / ('-' anyInt) / anyInt

anyInt <- hexInt / octalInt / binaryInt / decimalInt

decimalInt <- [1-9] (decimalDigit / '_' decimalDigit)+ / decimalDigit
decimalDigit <- [0-9]

hexInt <- '0x' hexDigit (hexDigit / '_' hexDigit)*
hexDigit <- [0-9A-Fa-f]

octalInt <- '0o' octalDigit (octalDigit / '_' octalDigit)*
octalDigit <- [0-7]

binaryInt <- '0b' binaryDigit (binaryDigit / '_' octalDigit)*
binaryDigit <- [01]

float <- [+\-]? ('nan' / 'inf' / floatDigits)
floatDigits <- decimalInt (floatFrac floatExp? / floatFrac? floatExp)
floatFrac <- '.' decimalDigit (decimalDigit / '_' decimalDigit)*
floatExp <- [eE] [\-+]? decimalDigit (decimalDigit / '_' decimalDigit)*

# -------------------------------------------------------------------------
# -- Escape Sequences

escaped <- escape ([btnfr"/\\] / 'u' hexQuad / 'U' hexQuad hexQuad)
escape <- '\\'

hexQuad <- hexDigit hexDigit hexDigit hexDigit

# -------------------------------------------------------------------------
# -- Strings

string <- (
    mlLiteralString
  / literalString
  / mlBasicString
  / basicString
)

basicString <- <'"' basicChar* '"'> { p.SetBasicString(p.buffer, begin, end) }

basicChar <- basicUnescaped / escaped

# This is basically the full printable range, excluding " and \
basicUnescaped <- [\t -!#-\[\]-\0x10FFFF]

mlBasicString <- '"""' mlBasicBody '"""' { p.SetMultilineBasicString() }

mlBasicBody <- (
    !'"""' '"' { p.AddMultilineBasicQuote() }
  / <basicChar / newline> { p.AddMultilineBasicBody(p.buffer, begin, end) }
  / escape newline wsnl
)*

literalString <- "'" <literalChar*> "'" { p.SetLiteralString(p.buffer, begin, end) }

literalChar <- [\t -&(-\0x10FFFF]

mlLiteralString <- "'''" <mlLiteralBody> "'''" { p.SetMultilineLiteralString(p.buffer, begin, end) }

mlLiteralBody <- (!"'''" (mlLiteralChar / newline))*

mlLiteralChar <- [\t -\0x10FFFF]

# -------------------------------------------------------------------------
# -- Datetimes

dateFullYear <- digitQuad
dateMonth <- digitDual
dateMDay <- digitDual
timeHour <- digitDual
timeMinute <- digitDual
timeSecond <- digitDual
timeSecfrac <- '.' decimalDigit+
timeNumoffset <- [\-+] timeHour ':' timeMinute
timeOffset <- 'Z' / timeNumoffset
partialTime <- timeHour ':' timeMinute ':' timeSecond timeSecfrac?
fullDate <- dateFullYear '-' dateMonth '-' dateMDay
fullTime <- partialTime timeOffset?
datetime <- (fullDate ([T ] fullTime)?) / partialTime

digitDual <- decimalDigit decimalDigit
digitQuad <- digitDual digitDual

# -------------------------------------------------------------------------
# -- Arrays

array <- (
    '[' { p.StartArray() }
    wsnl arrayValues? wsnl
    ']'
)

arrayValues <- (
    val { p.AddArrayVal() }
    (
        wsnl comment?
        wsnl arraySep
        wsnl comment?
        wsnl val { p.AddArrayVal() }
    )*
    wsnl arraySep?
    wsnl comment?
)

arraySep <- ','
